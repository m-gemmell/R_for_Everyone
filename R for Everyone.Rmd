--- 
title: "R for everyone"
author: "Matthew Gemmell"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
---

# Introduction
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/R.png", auto_pdf = TRUE)
``` 

This 8 week course will teach you the fundamentals of R. The first 2 weeks will focus on the basics of R with foundations and objects. Next we will look at how to read in files and write out files from R. In week 4 you will get further practice on the first 3 weeks whilst learning some handy tips and tricks.

You will then get to apply your R skills to create plots and carry out some statistics. In week 5 you will be creating line graphs and histograms. Week 6 will be creating scatterplots and boxplots. Week 7 will then be carrying out some basic statistics, don't worry it won't be a statistics lesson.

The final week will then be some harder coding where you'll learn to make loops, use ifs, and create R functions.

These materials will involve theory, pratice, exercises, and solutions:

- The theory will explain R concepts and terminolgy. R terminolgy can be quite confusing but it is important to learn as it makes asking questions online a lot easier.
- Practice will involve code to run whilst reading through the theory. This will allow you to see the output of R and hopefully help you understand how R works.
- Exercises will give you a task to carry out based on the knowledge and skills you learned from the theory and practise.
- Solutions for the exercise are after the exercise. Please try the exercise before looking at the solution, however make sure you read the solutions even if you completed the exercise successfully as there is extra information in these sections.
 
Commands are in the following font and colour and should be run in RStudio (These should not be copied into R from this document): 

```{r eval=FALSE}
This is a command 
``` 


<!--chapter:end:01-R_for_everyone.Rmd-->

# Week 1 - Foundations of R
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/foundational.png", auto_pdf = TRUE)
``` 
This week will cover the foundations of R. Understanding these concepts is fundamental to becoming an R user. We'll start with __operators__, these include __+, -, *, and /__, they allow us to use R like a calculator. Then we will look at __variables__. __Variables__ allow us to save the output from commands so we can use it in future commands. 

A lot of the power of R comes from the vast array of __functions__ it contains. We will therefore look at some useful __functions__ to see the how they work. We will then look at how to interact with directories in R.

We will end on some ways to use RStudio and the __script editor__.

## Operators
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/calculator.png", auto_pdf = TRUE)
``` 
__Operators__ are symbols in R that allow you to carry out many common tasks. The 3 main types of __operators__ in R are arithmetic, logical, and bitwise. We will ignore logical and bitwise and have a look at some arthimetic __operators__. 

The four most commonly used arthimetic __opertors__ are:

- `+` : Addition
- `-` : Minus
- `/` : Divide
- `*` : Multiply

Run the following commands in your RStudio __console__.

__Note:__ Each line below represents one command. Once a command is typed out press enter to run the command.

__Note:__ The amount of space between the integers/numbers and an operator does not matter. It is a matter of preference and clarity.

```{r eval=FALSE}
2+2
7-7
10/5
3*3
6+2+4
8-1-3
``` 

R follows the BODMAS rules (Brackets, Orders (powers/roots), Division, Multiplication, Addition, Subtraction). Try out the following commands to demonstrate the usefulness of brackets.

```{r eval=FALSE}
3 + 2 * 2/5
((3+2) * 2) / 5
3 - 2*4 + 1
(3-2) * (4+1)
3 * 3/2 * 2 - 1
(3*3) / ((2*2) - 1)
``` 

When entering commands via the __console__ the results/output is printed to the screen (ignore the [1] at the moment). However, this is no better than a normal calculator currently. R is a lot more powerful as we shall see.

## Variables
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/boxes.png", auto_pdf = TRUE)
``` 

The output/result of a command can be saved as a __variable__. Below is the format for creating a __variable__ in R (don't type this into R).

```{r eval=FALSE}
variable_name <- variable_object
``` 

There are 3 parts to the above:

- The __variable name__ (`variable_name`). This is the name of the __variable__ and is what will be used to refer to the __variable__ in future commands. This name can be almost anything. There are some rules on what can be in a name:
    - Must start with a letter.
    - Cannot contain spaces.
    - Cannot start with a number.
    - Cannot share the same name as a command or function in R.
    - They are case sensitive. The __variable__ name `BB` is differnet to the __variable__ name `bb` which is differnet again to `bB`. I find it easiest to keep __variable names__ in lower case.
- `<-` is called the assignment __operator__. It assigns the __variable object__ to the __variable name__. 
    - Tip you can press 'ALT'+ '-' after a __variable name__ as a shortcut for the assignment __operator__.
- The __variable object__ (`variable_object`). This can be many differnet objects including the output/results from commands, strings/words, numbers, and many other R data types.

A __variable__ can be thought of as a box. The __variable object__ is held in the box but it can be replaced with any another object. The __variable name__ can then be thought as the label on the box so you can tell which box is which.

Type the below commands into the RStudio __console__.

__Note.__ Remember the amount of spaces between __operators__ and __integers__ does not matter. I encourage you to experiment with this spacing so you find what is best for you in terms of ease and clarity.

```{r eval=FALSE}
bakers_dozen <- 13
kilobyte <- 1024
I <- 1
II <- I + 1
V <- 7 - II
X <- (II / I) * V
L <- X * V
``` 

In the above commands the __variables__ are not printed out to the screen, this is as it should be. The __variables__ are appearing in the __environment__ pane (Top right). This is very convenient to see what variables are currently in the __environment__ and to see what they contain. 

To print the contents of a __variable__ to screen you can type the __variable name__ into the __console__ and press enter. This will print the __variable object__ to the screen. This is not needed for small __variable objects__, for which you can look at the __environment__ pane, but is useful for larger __variable objects__.

## Functions
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/function.png", auto_pdf = TRUE)
``` 
R __Functions__ allow the user to carry out a specific task. R has many inbuilt __functions__ but you can also create your own. Currently we will look at in built functions.

The basic layout of a __function__ is:

```{r eval=FALSE}
function_name(objects, options)
``` 

There are 3 main parts to the above:

- The __function name__ (`function_name`)
- The __object/s__ to provide to the __function__. 
    - This can be numbers, strings, __variables__ we have created etc. 
    - Most __functions__ require at least one __object__. 
    - Some __functions__ can take multiple objects, if multiple __objects__ are provided they must be seperated by `,`.
- __Function__ options (`options`). Options can be provided to some __functions__ to alter the way they will work. 
    - Some __functions__ don't have options.
    - Most options have default modes. If the options is not specified the default mode will be used.
    - Like __objects__, if using multiple options they must be sperated by `,`.

Try running the below commands in your Rstudio __console__.

```{r eval=FALSE}
ceiling(3.5)
floor(3.5)
sqrt(9)
round(3.5555, digits = 2)
round(3.5555, digits = 3)
round(3.5555, digits = 0)
two <- sqrt(4)
``` 

The help page of __functions__ can be accessed in 2 main ways:

- Click on the __function name__ so your cursor is in it and press __F1__.
- Type `?` followed by the __function name__. Example below:

```{r eval=FALSE}
?ceiling
``` 

## Directories
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/directories.png", auto_pdf = TRUE)
``` 
It is important to know what directory you are working in and how to change to different directories.

### Commands
Below are commands you can run in the RStudio __console__ or __script editor__ (use of script editor will be taught soon).

- Determine what directory you are currently in:
```{r eval=FALSE}
getwd()
``` 

- Set working directory. The path of the directory must be in quotes like below. If you do run the below command make sure the path exists in your computer, as I am the sure the example below will not. 
```{r eval=FALSE}
setwd("/path/of/directory"")
``` 

- List the files in the current directory:
```{r eval=FALSE}
list.files()
``` 

### RStudio Interface
The RStudio interface can also be used to carry out the above tasks.

To see what the current working directory is, you can look at the top bar of the __console window__. The below shows I am in the __"F:/R/CE/CE_R_for_Everyone"__ directory. 

```{r, fig.align = 'center',out.width= '60%', echo=FALSE }
knitr::include_graphics(path = "figures/current_wd.png", auto_pdf = TRUE)
``` 

There are two main ways to set your working directory.

1. Via the tool bar:
    1. Click __"Session"__
    2. Go to the __"Set Working Directory"__ drop down section
    3. Click __"Choose Directory.."__
    4. Use the pop-up browser to choose a directory

2. Via the __MISC window__ (bottom left)
    1. Click the __Files pane__
    2. Navigate to the directory you would like to set as the working directory
    3. On the __MISC toolbar__ click __"More"__
    4. On the drop down click __"Set As Working Directory"__
    
To show the current working directory in the __Files__ pane click the arrow on the top bar of the __console window__. You can then see what files and directories are in your working directory via the __Files__ pane in the __MISC__ window.

```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/see_files.png", auto_pdf = TRUE)
``` 

With this information create a directory you will use for this course. This can be done outside of Rstudio or you can use the __Files pane__ in the __MISC window__. Once this is created set your working directory to it. With that done we can go onto the next section.

## Script editor
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/editor.png", auto_pdf = TRUE)
``` 
You can quickly type and run code using the __console window__. However, to fully utilse Rstudio we will instead use the __script editor__ in the __source window__. This allows us to reuse and edit code easier and it allows us to save our code so we can come back to it.

If you cannot see your __script editor__, click the multi window button on the top of the __source window__ or __console window__.
```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/script_editor_expand.png", auto_pdf = TRUE)
``` 

Type the below into the __script editor__ and press __"enter"__.
```{r eval=FALSE}
2 + 2
``` 

Pressing enter goes to a new line without running the command, just like other text editors (word, emails etc.).

On the new line type the below:

```{r eval=FALSE}
4 - 1
``` 

### Running commands
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/command.png", auto_pdf = TRUE)
``` 

You can run a command that is in the script editor by one of the two following ways:

- Via cursor:
    - Move the cursor to the line you would like to run.
    - Press __"Ctrl" + "enter"__ ( __"cmd"__ + __"enter"__ for Mac)
- Highlighting:
    - Highlight the parts you would like and press __"Ctrl" + "enter"__ ( __"cmd"__ + __"enter"__ for Mac)
    - You can highlight a part of a line, a whole line, and even multiple lines.

Run the commands you currently have in your __script editor__.

The __script editor__ is unaffected with only the cursor moving if you used the cursor method. Instead what is actually happening is your commands are being copied to the __console window__ and are being run there.

I would encourage to primarily use the script editor to write your code. It is brilliant for editing, reusing, and documenting your code.


### Annotations
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/hashtag.png", auto_pdf = TRUE)
``` 

Annotations can be added to your code in the __script editor__. If a line starts with a `#` it will not be run as a command, this line is then an annotation. This is extremely useful to leave information for your future self. It is much harder to go back to old code and figure out what it does if it is just code.

Be a mate, annotate.

Edit the contents of your __script editor__ so it looks like below. Then run all the lines.

__Tip__: If you have selected the __script editor__ you can use __"Ctrl"__ + __"a"__ to highlight all.

```{r eval=FALSE}
#Command 1
2 + 2
#Command 2
4 - 1
``` 

### Saving scripts
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/r_save.png", auto_pdf = TRUE)
``` 

Finally, one of the best aspects of using the __script editor__ is that you can save your scripts. I use this so I can have scripts for specific projects and template scripts for certain tasks I routinely carry out.

- To save a script you can click the floppy disk on the toolbar of the __source window__. 
- To save as, go to the RStudio toolbar and click __"File"__ > __"Save As..."__.

### Open a saved script
You can open a previously saved script in 2 main ways:


- Via the __Files pane__ in the __MISC window__
    - Navigate to the directory with the script (you do not need to set the working directory to this directory)
    - Click the name of the script you would like to open
- Via the Rstudio toolbar
    - Click __"File"__
    - Click __"Open file"__
    - With the popup browser navigate to the location of the script and open it

### New script
You can have multiple scripts open at one time and switch between these scripts with the tabs at the top of the __script editor window__.

To create and open a new script, click on the button on the RStudio toolbar shown below and select __"R script"__.

```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/new_script_button.png", auto_pdf = TRUE)
``` 


<!--chapter:end:02-Foundations.Rmd-->

# Week 1 exercises
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/kettle_bell.png", auto_pdf = TRUE)
``` 

This will be the simplest of the weekly exercises but will be a good oppurtunity to reinforce what you have learnt. In fact there is no solution section for this week as it is unneeded.

The first task is to add the below text annotation to the top of your current script.

```{r eval=FALSE}
# Foundations ####
```

Now save the file as __"Week1_practice.R"__ within the course directory.

For the next part you will need to create a new script and save it as __"Exercises.R"__.

On the first line of this script type the following annotation:

```{r eval=FALSE}
# Exercise 1 ####
```

The `####` creates a code section, these will be explained in a later week. You could also `----` or `====` at the end of an annotation to create a code section.

The next step is the most tedious, unfortunately tedious repetition is one of the best ways to learn.

Please fill in the __"Exercises.R"__ script with the commands from the __operators__ and __variables__ section from chapter 2. Additionally, add in annotations so you can easily tell which sections the commands come from and brief lines on their purposes.

Annotations require a balance of enough info but not too much info, you don't always need a line of annotation for each line of code. However, with some complex code sometimes you will need multiple lines of annotattion for one line of code. It is all about how much annotation you and possibly others will need for the code at hand. Knowing this requires experience.

Next save the script, ensuring it is called __"Day1_Exercises.R"__"

Finally, close your script by clicking the __"x"__" icon on the tab of the script.

That is the end of Week 1! If you have any questions please ask me (Matthew Gemmell) and I am more than happy to try to answer.

<!--chapter:end:03-Week_1_exercises.Rmd-->

# Week 2 - R objects
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/RObjects.png", auto_pdf = TRUE)
``` 
Last week we learnt how to create a __variable__. This consisted of assigning (`<-`) an __object__ a name. This week we will learn about __R objects__. There are two major R terminologies to learn to fully understand __R objects__.

- __Class__: An __R object__ will have a specific class. The __class__ determines what the __object__ is. It could be numbers, text, or other types of __classess__.
- __Data structure__: This determines the structure of an __R object__.

Today's plan is to learn about __classes__ and __data structures__.

## Code sections
Today, and for the rest of the course, you will use code sections in your R scripts to seperate sections in this book.

First set your working directory to the course directory, create a script, and save it as __"Week2_practice.R"__.

Next create a code section at the top of this script called __"Classes"__.

In other words have the below at the top of your script:

```{r eval=FALSE}
# Classes ####
```

## Classes
There are six basic __classes__ in R (Also known as the __atomic classes__). 

The four we will learn are:

- __Integer__
- __Double__
- __String__
- __Logical__. 

There are also the classes __complex__ and __raw__.

### Numeric
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/numbers.png", auto_pdf = TRUE)
``` 
__Numeric__ __classes__ come in two types, __integer__ and __double__. __Integers__ and __doubles__ are almost identical. However, __doubles__ contain decimal point information whilst __integers__ do not. 

Most of the time you will only need to know if your data is __numeric__ and you will not need to worry about __doubles__ or __integers__. The exception being if you are working with decimals and your decimals are not showing up. This probably means that your __object__ has the __integer class__.

Type and run the following, using the provided annotation to understand what the commands are doing.

__Note:__ Remember you can copy and paste old script.

Use the __function__ `class()` to show the __class__ of an R __object__:
```{r eval=FALSE}
#Numeric
#Class of 2
class(2)
#class of 3.14
class(3.14)
#class of 6
class(6)
```

Create a __variable__ with the __name__ "pie"" containing the __numeric__ 3.14:
```{r eval=FALSE}
#Creating a variable using the assignment operator
pie <- 3.14
```

Use the __functions__ `as.numeric()`, `as.integer()`, `as.double()` to print the __variable__ as a __numeric__, as an __integer__, and as a __double__:
```{r eval=FALSE}
#Printing out previously made variable as numeric, integer, and double
as.numeric(pie)
as.integer(pie)
as.double(pie)
```

You can put a __function__ as the __variable__ within a __function__. 

Below we will first check the __class__ of the __object__ within the "pie" __variable__. You will note that the __functions__ we used previously did not permanently change the __variable's object__. We can only change a __variable__ if we use the __assignment operator__.

Then we will check the __class__ of the __object__ as it is altered by the various `as.` __functions__. 

```{r eval=FALSE}
#Checking the class of our variable
class(pie)
class(as.numeric(pie))
class(as.integer(pie))
class(as.double(pie))
```

__Note:__ Remember to ask for help if you need it!

On a side note, R comes with some inbuilt variables such as pi:
```{r eval=FALSE}
#The R pi is equal to 3.141593
pi
#assign pi to 3.14
pi <- 3.14
#print out pi to see you have changed the variable's object
pi
#in this case if you want the original R pi object back, we can remove the one we made
rm(pi)
```

Have you been annotating your scripts?

### Logical
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/logical.png", auto_pdf = TRUE)
``` 
__Logical__ values can be __TRUE__ or __FALSE__. 

They are primarily used when comparing objects.

Run the below commands to output __Logical__ values using the various __logical operators__.

Note: when `!` is used in __operators__ it means "not". When used, `!` always goes at the front of the operator.

```{r eval=FALSE}
#Logical
# 2 less than 4 
2 < 4
# 2 greater than 4
2 > 4
# 2 less than or equal to 4
2 <= 4
# greater than or equal
2 >= 4
# equal
2 == 4
# not equal
2 != 4
```

It is probably not immediately obvious how useful __logicals__ but you'll see how they are later in the course.

### String
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/string_bubble.png", auto_pdf = TRUE)
``` 
__Strings__ are text and can be modified in R in ways you would normaly want to modify text. They are called __strings__ as they are strings of characters. __Strings__ are flanked by quote marks. Double quotes (`""`) are prefferred but single quotes can also be used (`''`).

Type and run the below examples to get some practice with __strings__.

A __string object__ can consist of a string containing one __character__:
```{r eval=FALSE}
#String
one_character_string <- "A"
one_character_string
```

A __string object__ can consist of a string containing multiple __characters__:
```{r eval=FALSE}
word_string <- "alphabet"
word_string
```

A __string__ can contain all the different characters and any number of them. The only exception is that if you try to put a double quote in your string it will cause an issue.
```{r eval=FALSE}
long_string <- "Strings can be long and contain more than letters. \\.("
long_string
```

A __string__ doesn't need letters, it can consist of only numbers. Note the terms __string__ and __character__ can be used interchangeably.
```{r eval=FALSE}
number_string <- "1066"
number_string
class(number_string)
```

You can convert a __numeric__ to a __string/character__.
```{r eval=FALSE}
number <- 1066
numeric_to_string <- as.character(number)
numeric_to_string
class(numeric_to_string)
```

An appropriate __string__ can be converted to a __numeric__. This is useful as mathematical __operators__ will not work with __strings__.
```{r eval=FALSE}
#will get an error as strings and maths don't mix
"6" - 3
#will work as maths and numerics work
as.numeric("6") - 4
#Below will not work as only strings containing numbers can be converted to numeric
as.numeric("not_a_number_12")
```

You can use certain __logical operators__ to compare __strings__ though:
```{r eval=FALSE}
"character" == "character"
"1066" != "character"
"numeric" == "string"
```

The __paste() function__ is very useful to combine two or more __strings__ into one.
```{r eval=FALSE}
paste("The following is a string:", long_string) 
paste(number_string, "is a", word_string)
#By default paste will put a spaces between each string you provide
#You can use the sep option to specific your own
paste("However", " this is seperated by a comma", sep = ",")
#Or you can make it so there is no seperator
paste("no seperator",numeric_to_string, sep = "")
```

## Code section continued
After all that you will have some nice code and annotations in your script editor for the __Classes__ code section.

Making a code section is not very useful until you have multiple code sections. To show this create a new code section at the bottom of your script called __"Data structures"__. This new code section will be used for the next section.

```{r eval=FALSE}
# Data structures ####
```

With the new code section created we can now see why code sections are so useful. Go to the text that denotes the first code section (__"Classes"__). Look between the numbers on the left that signify the line number, and the text. You will see an arrow pointing downwards. You can click that arrow and it will collapse the code section. Click the arrow, now pointing right, and it will expand the code section. This is super useful so you can hide code sections in your script that you don't currently need to look at.

```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/R_code_section_collapse.png", auto_pdf = TRUE)
``` 

With the __"Classes"__ code section collapsed let us continue to the next section. There will be less annotations in this book as I expect you will make your own now.

## Data structures

__Data structures__ describe how data is structured in an __object__. We will go into 3 main types of __data structures__.

- __Scalar__
- __Vectors__ & __Lists__
- __Matrices__ & __Data frames__

###Scalar
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/Rscalar.png", auto_pdf = TRUE)
``` 
A __scalar__ consists of one value in an object. This can be one __string__, one __numeric__, one __logical__ etc. We have only been working with __scalars__ thus far but this is about to change. 

###Vectors & Lists
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/Rvector.png", auto_pdf = TRUE)
``` 
A __R object__ can hold multiple values.Many __data__ structures can do this with the simplest being a __vector__.

A __vector__ can be created with the `c()` __function__. This function will combine the provided objects into a single __vector__ or __list__.

__Vectors__ and __lists__ are both 1-dimensional __data structures__. __Vectors__ can only contain one __class__ (homogeneous) whilst __lists__ can contain multiple (heterogeneous). There is more to __lists__ but we will not go into them.

Run the following commands to produce __variables__ which contain __vectors__.
```{r eval=FALSE}
number_vec <- c(1,2,4,8,16)
number_vec
number_series_vec <- 1:6
number_series_vec
animals <- c("Whale","Seal","Hedgehog","Mouse","Owl","Squirrel","Vole","Shrew")
animals
```

Elements of a __vector__ can be accessed through their indices:
```{r eval=FALSE}
birds <- animals[5]
birds
aquatic <- animals[1:2]
aquatic
rodents <- animals[c(3,6,7)]
rodents
mammals <- animals[-5]
mammals
```

You can use __operators__ and __functions__ on a __vector__. When you do each __scalar__ within the __vector__ will be acted upon.
```{r eval=FALSE}
number_vec - 1
number_vec * 2
log(number_vec)
length(rodents)
```

Some __functions__ are specifically used for __vectors__:
```{r eval=FALSE}
mean(number_vec)
summary(number_vec)
```

We can also test the values within __vectors__:
```{r eval=FALSE}
aquatic == "Whale"
number_vec > 4
number_vec[number_vec > 4]
```

The `paste()` __function__ can be used to paste __string scalars__ to other __string scalars__ or to __string vectors__:
```{r eval=FALSE}
paste("Animals", animals)
bird_or_mammal <- c("mammal","mammal","mammal","mammal","bird","mammal","mammal","mammal")
paste(animals, bird_or_mammal, sep = ":")
paste(animals, " is a ", bird_or_mammal, sep = "")
```

###Data frames & Matrices
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/Rmatrix.png", auto_pdf = TRUE)
``` 

__Data frames__ & __matrices__ are 2-dimensional data structures as they have rows and columns.

A __matrix__ only contains 1 __class__ (homogeneous). A __data frame__ can contain multiple classes (heterogenous), but each column can only contain one __class__. 

Most of the time __data frames__ and __matrices__ can be treated the same. Because of this I generally use __data frames__ and so we will focus on them.

R comes with a set of pre-loaded data. If you are interested you can use the __function__ `data()` to see the full list.

We will have a quick look at the dataset "mtcars". This is a __data frame__ containing information on various cars. To look at the __data frame__ in the __console window__ run the below.

```{r eval=FALSE}
mtcars
```

To get a better look save the __data frame__ as a __variable__.
The above shows the info in the __console window__. However we can have a better look at it in RStudio if we save it as a variable in our __environment__ and then click the variable on the __Environment pane__ of the __"environment and history"__ __window__.
```{r eval=FALSE}
cars_info <- mtcars
```

Now the __variable__ will be listed in your __Environment pane__ in the __"environment and history" window__ . Click on the name "cars_info" in the __Environment pane__. A tab in your __script editor__ will open so you can have a good look at the contents of the __data frame__.

When you are ready, close the "cars_info" tab and remove the __variable__ with the below command.
```{r eval=FALSE}
rm(cars_info)
```

Now it is time to create our own __data frame__.

First we will create three __variables__ containing __vectors__. These will be our three columns.
```{r eval=FALSE}
Crab <- c(10,1,1)
Oystercatcher <- c(5,6,4)
Starfish <- c(3,3,7)
```

Now let us create the __data frame__. 
```{r eval=FALSE}
#Using the function data.frame to create a data frame
beach_df <- data.frame(Crab,Oystercatcher,Starfish)
```

Look at the __variable__ "beach_df" (it is useful to use "df" in __variable names__ to signify it is a __data frame__) and you will see that each __vector__ has become a column. The __variable names__ have become the column names (this is why we used capital letters in the __variable names__).

You can think of __data frames__ in three differnet ways:

- A list of columns
- A list of rows
- A table

Look at the column and row names with two new __functions__.
```{r eval=FALSE}
colnames(beach_df)
row.names(beach_df)
```

We can use the __function__ `row.names()` and the __assignment operator__ to change the row names to something more useful.
```{r eval=FALSE}
row.names(beach_df) <- c("Formby","West Kirby","Crosby")
```

Now look at your "beach_df" __data frame__ to see the difference.

That is quite a lot to go through so let us reinforce it all with exercise!

<!--chapter:end:04-R_objects.Rmd-->

# Week 2 exercises
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/beach.png", auto_pdf = TRUE)
``` 
For this exercise simply produce the following tables as __data frames__ in R. Please carry this out in your __"Exercises.R"__ script and remember about code sections and annotations.

Tip: You can either write completely new code or reuse and alter previous code. 

##df

__Note__: The top row is the column names and the left-most column is the row names.

```{r echo = FALSE, results = 'df'}
library("knitr")
One <- c(2,4,6)
Three <- c(6,12,18)
Five <- c(10,20,30)
row_names <- c("Two", "Four", "Six")
df <- data.frame(One,Three,Five)
row.names(df) <- row_names
kable(df)
```

##beach_df_2

__Note__: The top row is the column names and the left-most column is the row names.

```{r echo = FALSE, results = 'nut_df_2'}
library("knitr")
Crab <- c(10,1,1,4)
Oystercatcher <- c(5,6,4,4)
Sandpiper <- c(1,1,2,3)
Starfish <- c(3,3,7,4)
row_names_2 <- c("Formby","West Kirby","Crosby","New Brighton")
beach_df_2 <- data.frame(Crab,Oystercatcher,Sandpiper,Starfish)
row.names(beach_df_2) <- row_names_2
kable(beach_df_2)
```

<!--chapter:end:05-Week_2_exercises.Rmd-->

# Week 2 exercise solutions
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/week2_solutions.png", auto_pdf = TRUE)
``` 

##df solution
###Step 1
Create __vectors__ for columns and row names:
```{r eval=FALSE}
One <- c(2,4,6)
Three <- c(6,12,18)
Five <- c(10,20,30)
row_names <- c("Two", "Four", "Six")
```

###Step 2a
Create the __data frame__ from vectors:
```{r eval=FALSE}
df <- data.frame(One,Three,Five)
```
Add row names:
```{r eval=FALSE}
row.names(df) <- row_names
```
###Step 2b
Alternatively you can define the row names in the `data.frame()` `function` as an option:
```{r eval=FALSE}
df <- data.frame(One,Three,Five, row.names = row_names)
```

##beach_df_2 solution
###Step 1
Create __vectors__ for columns and row names:
```{r eval=FALSE}
Crab <- c(10,1,1,4)
Oystercatcher <- c(5,6,4,4)
Sandpiper <- c(1,1,2,3)
Starfish <- c(3,3,7,4)
row_names_2 <- c("Formby","West Kirby","Crosby","New Brighton")
```
###Step 2a
Create the __data frame__ from __vectors__:
```{r eval=FALSE}
beach_df_2 <- data.frame(Crab,Oystercatcher,Sandpiper,Starfish)
```
Add row names:
```{r eval=FALSE}
row.names(beach_df_2) <- row_names_2
```
###Step 2b
Alternatively you can define the row names in the `data.frame()` __function__ as an option:
```{r eval=FALSE}
beach_df_2 <- data.frame(Crab,Oystercatcher,Sandpiper,Starfish, row.names = row_names_2)
```

<!--chapter:end:06-Week_2_exercise_solutions.Rmd-->

# Week 3 - Files and subsetting data
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/R_df.png", auto_pdf = TRUE)
``` 

##Reading from a file
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/r_read.png", auto_pdf = TRUE)
``` 

Last week we created __data frames__ with R __functions__. This was useful to help understand how __data frames__ work in R. However, in real life you will most likely not do this very often. Instead you are more likely going to have data files you need to analyse with R.

You can get your data into R by having R __read__ your file.

The first task to carry out this week is to __read__ in the file "Liverpool_beaches.csv". Before __reading__ in the file we can check the contents of the file. This can be carried out by opening it with notepad (or similar text tool) or viewing the file with RStudio. 

To view the file with RStudio:

- Use the __Files pane__ of the __MISC window__ to navigate to the directory containing the file.
- Click on the file name and then click "View File"
- This will open a tab in the __Source window__ matching the file name

You will notice that the values are sperarated by commas as this is a "comma seperated value" (.csv) file. Additionally, this is the same data as the "beach_df_2" __data frame__ you created in last week's exercises. 

There are various __functions__ to __read__ in files into R. My favourite that I find most consistent is `read.csv(). Use this function to __read__ in the file "Liverpool_beaches.csv":
```{r eval=FALSE}
liv_beaches_df <- read.csv("Liverpool_beaches.csv")
```

Have a look at the newly created __data frame__. Is it how you would like it?

The row names are empty and the beach names are in the first column. Let us fix this and make it so the beach names are the row names. This can be carried out by including the option `row.names = 1` to specify the 1st column will be the row names:
```{r eval=FALSE}
liv_beaches_df <- read.csv("Liverpool_beaches.csv", row.names = 1)
```

We know how to __read__ in a csv file with `read.csv`, now let us __read__ in a tab seperated file with `read.csv`. As before first look at the file contents before __reading__ them in. It contains the sales figures of fictional clothing stores through the seasons.

Now use `read.csv()` to __read__ in the file. We'll set `row.names = 1` again but we will also include the option `sep = "\t"`. This option specifies the columns are sperated (sep) by tabs (`"\t"`).

```{r eval=FALSE}
clothing_df <- read.csv("Clothing_stores.txt", row.names = 1, sep = "\t")
```

Look at the resulting __data frame__ and you will notice the column names have been changed by R. This is annoying but thankfully there is an easy fix. __Read__ in the data again with the inclusion of the parameter `check.names = FALSE`. This will stop the function `read.csv()` from 'checking' and 'fixing' the column names. I always use this option.
```{r eval=FALSE}
clothing_df <- read.csv("Clothing_stores.txt", row.names = 1, 
                        sep = "\t", check.names = FALSE)
```

You may want to open excel files with R. Normally to do this I open the file in excel and save it as a .csv or a tab seperated file and __read__ this into R. Alternatively there are R packages that can directly __read__ in excel files. If this is something you would like to do you can look at the following package:

https://readxl.tidyverse.org/

An important note is that __reading__ in a file into R will not change the file. You are creating a new R __object__. Modifying this __object__ will not alter the original file. Later in the materials we will look into how to create new files or overwrite files by __writing__.

##Subsetting data
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/R_subset.png", auto_pdf = TRUE)
``` 

R allows you to specify specific points in __R objects__. This is one of the primary reasons R is so useful and flexible. With good use of __assignment operators__ this allows for the subsetting of __variables__.

###Vectors
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/R_square_bracket.png", auto_pdf = TRUE)
``` 

We will start with __vectors__. Before carrying out and subsetting let us create some new __vectors__. We will use a new __function__ to create these, `seq()`.

__Tip__: Look at the resulting __vectors__ and, use `?seq()` or search online to understand the `seq()` __function__ better.
```{r eval=FALSE}
even_seq <- seq(from = 0, to = 8, by = 2)
odd_seq <- seq(from = 1, to = 9, by = 2)
long_seq <- seq(from = 10, to = 300, by = 10)
```

Grand! Now let us subset the __vectors__ with square brackets `[]`.

__Vectors__ are one-dimensional, we therefore provide the square brackets with one number or one range of numbers. The number/s we provide in the square brackets are  the index.

Try out indexxing/subsetting the __vectors__.

```{r eval=FALSE}
even_seq[2]
odd_seq[1]
long_seq[10]
even_seq[2:3]
odd_seq[1:4]
long_seq[21:24]
long_seq[24:21]
even_seq[c(2,3)]
odd_seq[c(1,3,2,5)]
long_seq[c(1,21,21:24,24:21,1)]
#As long as the contents within the [] equal numbers they will work
even_seq[seq(from = 1, to = 3, by = 2)]
even_seq[seq(from = 0, to = 5, by = 3)]
long_seq[seq(from = 1, to = 19, by = 2)]
even_seq[1*2]
odd_seq[2/1]
long_seq[(1:10)*2]
```

The __vectors__ even_seq and odd_seq have the indexes 1,2,3,4, and 5 as they each contain 5 __scalars__. What if we try to use a higher number to index than is avalable?
```{r eval=FALSE}
even_seq[6]
even_seq[c(4,7)]
odd_seq[3:9]
```

As you can see the above all work with no complaints. Any indexes that are out of range will return a `NA` value. `NA` stands for 'Not Available'. We will not go into how `NA` works in R too much. The most important thing to know about `NA` is that you will most likely get `NA` if you use __operators__ or __functions__ with `NA`. Below are a few examples:

```{r eval=FALSE}
#Will give NA
1 + NA
2 - NA
even_seq[2] * NA
odd_seq[5] / NA
#mean() function without NA
mean(even_seq[2:5])
#mean() function with NA
mean(c(1,2,3,4,5,NA))
mean(even_seq[2:7])
```

Above we subsetted __vectors__ by specifying which indexes we want. We can also specify which indexes we don't want:
```{r eval=FALSE}
even_seq[-2]
odd_seq[-3:-5]
long_seq[c(-1,-2,-6)]
```

The `rep()` __function__ will replicate a __scalar/vector__ a specified amount of times. We will use this __function__ to overwrite our previously created __variables__ with longer versions:
```{r eval=FALSE}
#Replicate vector even_seq 2 times
rep(x = even_seq, 2)
#Replicate vector even_seq 4 times and then assign even_seq as the newly created vector
even_seq <- rep(x = even_seq, 4)
#More examples
odd_seq <- rep(x = odd_seq, 4)
long_seq <- rep(x = long_seq, 3)
```

__Logical__ __operators__ can be used as indexes to subset __vectors__. Having a logical expression (i.e. 1 > 2) as the index will cause all TRUE positions to be included and all FALSE positions to be excluded.


__Tip__: If it is difficult to deduce what the below commands are doing you can run the part in the square brackets by itself. Remember if you highlight code in the __script editor__ it will only run that part, including parts of script in the same line.
```{r eval=FALSE}
even_seq > 3
even_seq[even_seq  > 2]
odd_seq[odd_seq <= 1 ]
long_seq <- long_seq[long_seq < 50]
```

We will quickly look at a new __operator__, `%%`. This is the modulus __operator__, it divides two numbers and gives the remainder of the division.

With the modulus __operator__, logical expressions, and subsetting we can extract even or odd numbers from a __vector__:
```{r eval=FALSE}
#First some basic modulus examples
2%%2
3%%2
#Create a vector with numbers 0 to 9
single_digit_vec <- 0:9
#Extract even numbers then odd numbers from the vector
#We carry this out by determining if numbers are divisible by 2 or not
even_seq <- single_digit_vec[(single_digit_vec %% 2) == 0 ]
odd_seq <- single_digit_vec[(single_digit_vec %% 2) != 0]
#We can determine which numbers in a vector are divisible by any specific number
#Divisible by 3
#remember variable names cannot start with numbers
divis_3_vec <- single_digit_vec[(single_digit_vec %% 3) == 0]
#Divisible by 7
divis_7_vec <- single_digit_vec[(single_digit_vec %% 7) == 0]
#Try out other numbers!
```

###Data frames
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/envelope.png", auto_pdf = TRUE)
``` 

__Data frames__ can be subset similar to __vectors__. As with __vectors__ you can use `[]`. Additonally `$` can be used to subset __data frames__.

Square brackets must be provided indexes for rows and for columns. The structure for this is `df[row,column]`. It is very useful to remember that R always wants rows first then columns second.

To practice subsetting __data frames__ with square brackets we will __read__ in a new file called "Census_2011_L_postcodes.csv". This contains UK 2011 census information on total residents for postcodes that start with the letter L. Data can be found:

https://www.nomisweb.co.uk/census/2011/postcode_headcounts_and_household_estimates

```{r eval=FALSE}
L_2011_census_df <- read.csv("Census_2011_L_postcodes_counts.csv", check.names = FALSE,
                             row.names = 1)
```

Now for some subset commands:
```{r eval=FALSE}
#Scalar from the 1st row and 1st column
L_2011_census_df[1,1]
#Row names and column names can be used for indexxing
#Scalar from the row called L10 1LD: E00033706 and the column called Postcode
L_2011_census_df["L10 1LD","Area"]
#More examples
L_2011_census_df[1:10,2]
L_2011_census_df[1:10,"District"]
L_2011_census_df[3,2:4]
L_2011_census_df["L10 1LD",2]
L_2011_census_df[1:10,"Total"]
L_2011_census_df[c(1,3,5,6),c("Total","Occupied_Households")]
```

Depending on how you subset a __data frame__ you may get a __scalar__, __vector__, or __data frame__. Below describes which you will get based on the subsetting.

- __Scalar__: 
    - Indexxing to get a single value by choosing one row and one column.
    - E.g. `L_2011_census_df[1,1]`
- __Vector__:
    - Indexxing so you get multiple values from one column. This occurs as each column is in essence a __vector__.
    - E.g. `L_2011_census_df[1:10,2]`
- __Data frame__:
    - Indexxing so you get multiple values from a row or multiple rows. Subsetting a __data frame__ like this provides you a __data frame__.
    - E.g. `L_2011_census_df[3,2:4]` or `L_2011_census_df[3:4,2:4]`

A quick __function__ to subset a __data frame__ is `head()`. By default it will return the first 6 rows.
```{r eval=FALSE}
#Return first 6 rows
head(L_2011_census_df)
#Return first 10 rows
head(L_2011_census_df, 10)
```

The __data frame__ is quite large. We will therefore use the `head()` __function__ and the __assignment operator__ to make the __data frame__ smaller for further examples.

```{r eval=FALSE}
L_2011_census_df <- head(L_2011_census_df, 20)
```

To return all the rows of the specified columns you can leave the part before the comma empty. Similarly you can leave the part after the comma empty to return all of the columns of the specified rows. Leave both sides empty and you will get the entire __data frame__.

```{r eval=FALSE}
L_2011_census_df[,]
L_2011_census_df[,2]
L_2011_census_df[3,]
L_2011_census_df[,"District"]
L_2011_census_df[2:4,]
```

The sign `$` allows you to indicate which column you would like from the __data frame__. This is done like so:
```{r eval=FALSE}
L_2011_census_df$Area
L_2011_census_df$District
L_2011_census_df$Total
```

You will notice that the above commands return __vectors__. We can therefore subset these __vectors__ with `[]`:
```{r eval=FALSE}
L_2011_census_df$Area[2]
L_2011_census_df$District[2]
L_2011_census_df$Total[4:7]
```

Below are a selection of useful __functions__ that can be used on __vectors__.
```{r eval=FALSE}
#Sum the values of a numeric vector
sum(L_2011_census_df$Total)
#Mean of the values of a numeric vector
mean(L_2011_census_df$Total)
```

The above __functions__ are useful but limiting if you are working with __data frames__. Thankfully there are also many __functions__ used specifically for __data frames__ (they can also be used for matrices).
```{r eval=FALSE}
#Sum numeric columns
colSums(L_2011_census_df[,3:6])
#Sum numeric rows
rowSums(L_2011_census_df[,4:5])
#Mean of numeric columns
colMeans(L_2011_census_df[,3:6])
#Mean of numeric rows
rowMeans(L_2011_census_df[,4:5])
#Summary information for each column
#This works for string and numeric columns with different outputs
summary(L_2011_census_df)
```

Try out some of the above commands with the entire __data frame__. Do they give an error? Is so, why?

Before we learn how to __write__ data to a file I will introduce one more __data frame__ associated __function__. `t()` which stands for transpose:
```{r eval=FALSE}
L_2011_census_df[3:5]
t(L_2011_census_df[,3:5])
summary(t(L_2011_census_df[,3:5]))
```

Try the above commands without subsetting the __data frame__. What is happening and why?

##Writing to a file
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/R_writing.png", auto_pdf = TRUE)
``` 

Before we __write__ data to a file we will create a new __data frame__ from "L_2011_census_df". 

First I like to create a new __variable__ from our old __variable__ if there are many steps. This means if we make a mistake we can go back and recreate the new __variable__.
```{r eval=FALSE}
L_2011_census_t_df <- L_2011_census_df
```

Next step we will create a new column called "Average_per_occupied_households".

__NOTE__: I am including many ways to subset columns as reminders. Normally I wouldn't have so many different ways in one command.

__NOTE__: We are using "_" instead of spaces as R doesn't particularly like spaces in column names. We will see how to use spaces later.
```{r eval=FALSE}
L_2011_census_t_df$Average_per_occupied_households <- 
  L_2011_census_t_df[,3] / L_2011_census_t_df[,"Occupied_Households"]
```

Have a look at the current __data frame__. You may notice an `Inf` value. This appears as when you divide a number by 0 in R you will get `Inf`. I am not sure how a Post code has 174 residents and 0 Occupied households but it doesn't matter for us.

The final step before writing is to transpose the __data frame__ leaving out the Area and District columns:
```{r eval=FALSE}
#Transpose dataframe
L_2011_census_t_df <- t(L_2011_census_t_df[,3:7])
#Check structure
str(L_2011_census_t_df)
#It is not a dataframe
#Let us therefore convert it to a data frame
L_2011_census_t_df <- as.data.frame(L_2011_census_t_df)
#Structure check
str(L_2011_census_t_df)
```

After all that let us __write__ the __data frame__ to a file called "Census_info_2011.csv". When __reading__ from a file a prefer `read.csv()`, however when writing to a file I prefer `write.table()`. With this __function__ we will include the option `sep=","` to have commas as the column seperators. We will also include the option `col.names=NA` to create an empty space above the row names. If this was not included then the first column name would be above the row names.
```{r eval=FALSE}
write.table(L_2011_census_t_df, file = "Census_info_2011.csv", sep = ",", col.names=NA)
```

Have a look at the file contents with RStudio.

Let us do it one more time with the clothing store info. First let us __read__ in the file again in case you do not have it. Then we will create a total sales column and finally transpose the __data frame__:
```{r eval=FALSE}
#Read in
clothing_df <- read.csv("Clothing_stores.txt", row.names = 1, 
                        sep = "\t", check.names = FALSE)
#Create total column
#We are referring to a column name with spaces
#Therefore we must surround the name with `
#The button for ` is left of the 1 key and below the esc key
clothing_df$`Total sales` <- rowSums(clothing_df)
#Transpose ensuring output is a data frame
clothing_t_df <- as.data.frame(t(clothing_df))
```

__Write__ the __data frame__ to a tab delimited file (.tsv). This time we will make it so the row and column names are not surrounded by quotes:
```{r eval=FALSE}
write.table(clothing_t_df, 
            "Clothing_stores_transposed.tsv", 
            sep = "\t",  
            col.names=NA, 
            quote = FALSE)
```

With the fundamentals of __reading__, subsetting __data frames__, and writing covered it is time to carry out some exercises.

<!--chapter:end:07-Files_and_subsetting_data.Rmd-->

# Week 3 exercises
This exercise will look at two files. You will be assigned tasks requiring you to __read__ and __write__ files as well as index __data frames__

## Bats
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/bat.png", auto_pdf = TRUE)
``` 

First we will look at the file "bat_roosts.csv". This contains information on the max number of roosts for different Bat species in different UK regions. 

The data is from: "Bat Conservation Trust 2020. Roost Count peak counts summary data. Available from https://www.bats.org.uk/our-work/national-bat-monitoring-programme/reports/nbmp-annual-report"

For this file carry out the below tasks:

1. __Read__ in the file "bat_roosts.csv" as a __data frame__ __variable__ called "bat_df". Ensure the row names contain the Regions (Channel Islands, East Midlands, etc.)
2. Inspect the __variable__ and ensure there are only numerics within the __data frame__ with all strings only being in column and row names.
3. Add a row to "bat_df" called "UK" that contains the totals for each Species.
4. Add a column to "bat_df" called "All_Bat_Species" that contains the totals for each Region.
5. Create a transposed __data frame__ of "bat_df" called "bat_t_df".
6. __Write__ the __data frame__ "bat_t_df" to a comma seperated file called "bat_roosts_t.csv". Ensure there are no quotes surrounding the row or column names.

Now that you have carried that out, can you answer the following questions?

1. Which region has no roosts?
2. Which Bat species has the highest number of roosts across the UK?
3. Which Bat species has the lowest number of roosts across the UK?

## UK retail
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/UKPounds.png", auto_pdf = TRUE)
``` 

Next we have a file ("UK_retail.txt") containing UK retail information for each month from September 2017 to September 2020. The values are seasonally adjusted volume sales. The data comes from: https://www.ons.gov.uk/businessindustryandtrade/retailindustry/bulletins/retailsales/september2020.

Carry out the below tasks:

1. __Read__ in the file "UK_retail.txt" as a __data frame__ __variable__ called "uk_retail_df". Ensure the row names contain the YearMonth info (2017SEP, 2017OCT, etc.).
2. Create a __data frame__ called "retail_2020_df" containing the rows for 2020 from "uk_retail_df". 
3. For each month in 2020 print out the phrase "The Food retail index for \<YearMonth> was \<Food>". For example the first phrase will be "The Food retail index for 2020JAN was 101.9". This can be done with one line of code using the `paste()` function.
4. Make a total row and an average (mean) row for "retail_2020_df". Ensure you are not including the total in the mean.
5. Finally write out the __data frame__ "retail_2020_df" as a tab seperated file called "UK_retail_2020.tsv".

Now that you have carried that out, can you answer the following questions?

1. Which retail sectors have a lower average than their February 2020 value?
2. Which retail sector was the highest for 2020?
3. Which sector was the most stable?

Great! Have a look at the solution, ask any questions you would like, then that is the end of this week.

<!--chapter:end:08-Week_3_exercises.Rmd-->

# Week 3 exercise solutions

Before looking at these solutions keep in mind that there are many different ways to do the same thing in R. Therefore if your scripts are different than the ones below it does not mean they are wrong. As long as they produce the intended output they are correct.

## Bats solution
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/bat.png", auto_pdf = TRUE)
```

Read in the file as a __data frame__:
```{r eval=FALSE}
bat_df <- read.csv("bat_roosts.csv", row.names = 1, check.names = FALSE)
```

Add a row with column totals:
```{r eval=FALSE}
bat_df["UK",] <- colSums(bat_df) 
```

Add a column with row totals:
```{r eval=FALSE}
bat_df$All_Bat_Species <- rowSums(bat_df) 
```

Create transposed __data frame__:
```{r eval=FALSE}
bat_t_df <- as.data.frame(t(bat_df)) 
```

__Write__ file:
```{r eval=FALSE}
write.table(bat_t_df, file = "bat_roosts_t.csv", sep = ",", quote = FALSE, col.names = NA)
```

## UK retail solution
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/UKPounds.png", auto_pdf = TRUE)
``` 

Read in file:
```{r eval=FALSE}
retail_df <- read.csv("UK_retail.txt", sep = "\t", row.names = 1, check.names = FALSE)
```

Create 2020 __data frame__:
Read in file:
```{r eval=FALSE}
#Can index to get the desired columns
retail_2020_df <- retail_df[29:37,]
#Alternatively the tail() function can be used
#It is like head() but will get lowest rows
retail_2020_df <- tail(retail_df, n = 9)
```

Print food index phrases
```{r eval=FALSE}
paste("The Food retail index for", row.names(retail_2020_df),
      "was", retail_2020_df$Food, 
      sep = " ")
```

Total and mean rows
```{r eval=FALSE}
retail_2020_df["Total",] <- colSums(retail_2020_df)
retail_2020_df["Average",] <- colMeans(head(retail_2020_df, n = 9))
```

Write out file:
```{r eval=FALSE}
write.table(retail_2020_df, "UK_retail_2020.tsv", 
            sep = "\t", col.names = NA, quote = FALSE)
```

<!--chapter:end:09-Week_3_exercise_solutions.Rmd-->

# Week 4 - Handy tips & tricks

```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/magic.png", auto_pdf = TRUE)
```

Welcome to week 4! This week will include coding to reinforce what you have learnt up to this point. There will also be plenty of new handy __functions__ and some more concepts to learn.

For this week create a script called "Week3_practice.R". Remember to use annotations (`#`) and code sections (`####`)!

However, I'll first introduce you to some R conventions and then some useful abilities of RStudio.

## R conventions
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/rules.png", auto_pdf = TRUE)
```

R conventions are style guides. You do not need to follow them but they are intended to help make code easier to read. There are lots of different suggestions for different parts of R code. Here we will only look at conventions for __object/variable names__ and wide vs long code formatting.

###Variable names
__Variable names__ have certain rules that must be followed. We covered these in week 1 but below is a reminder:

- Must start with a letter.
- Cannot contain spaces.
- Cannot start with a number.
- Cannot share the same name as a command or function in R.
- They are case sensitive. The __variable__ name `BB` is differnet to the __variable__ name `bb` which is differnet again to `bB`.

On top of these rules there are a few naming styles that are recommended. It is very good to choose one naming style and stick with it always. Below are three commonly used naming conventions for R. Look through them and choose your favourite to use.

####Snake case
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/snake_case.png", auto_pdf = TRUE)
```
Snake case is my preferred naming convention due to my background. It consists of using lower case letters with underscores (`_`) between words. Numbers can also be used. Below are some examples of names in snake case.

```{r eval=FALSE}
one
two_df
two_2_df
three_four_five
three_four_five_2_vec
this_is_snake_case
``` 

####Period separated
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/period_separated.png", auto_pdf = TRUE)
```
Period seperated is almost identical to snake case. Just swap the underscores (`_`) with periods (`.`). Below are some examples of names in period separated.

```{r eval=FALSE}
one
two.df
two.2.df
three.four.five
three.four.five.2.vec
this.is.period.separated
``` 

####Camel case
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/camelCase.png", auto_pdf = TRUE)
```
Camel case has no symbols to separate words. Instead after the first word every word starts with an upper case. Below are some examples of names in Camel Case. 

```{r eval=FALSE}
one
twoDf
two2Df
threeFourFive
threeFourFive2Vec
thisIsCamelCase
``` 

There are exceptions when you will want to break your naming style such as when creating __vectors__ to be used as columns for a __data frame__.

###Wide vs Long coding

If a command/__function__ is only on one line then you were using wide coding. This is good with short commands and __functions__ but is not very suitable for longer commands. Below are examples of long commands over one line each.
```{r eval=FALSE}
#Create a data frame called df
df <- data.frame(one = c(2,4,6), three = c(6,12,18), five = c(10,20,30), row.names = c("Two", "Four", "Six"))
#Create a data frame called beach_df_2
beach_df_2 <- data.frame(Crab = c(10,1,1,4) ,Oystercatcher = c(5,6,4,4),Sandpiper = c(1,1,2,3) ,Starfish = c(3,3,7,4), row.names = c("Formby","West Kirby","Crosby","New Brighton"))
```

Compare the above with the below long coding where arguments are separated by new lines.
```{r eval=FALSE}
#Create a data frame called df
df <- data.frame(one = c(2,4,6), 
                 three = c(6,12,18), 
                 five = c(10,20,30), 
                 row.names = c("Two", "Four", "Six"))
#Create a data frame called beach_df_2
beach_df_2 <- data.frame(Crab = c(10,1,1,4), 
                         Oystercatcher = c(5,6,4,4),
                         Sandpiper = c(1,1,2,3),
                         Starfish = c(3,3,7,4), 
                         row.names = c("Formby","West Kirby","Crosby","New Brighton"))
```

Hopefully you will agree with me that the long coding is a lot easier and quicker to read.

If you are interested in more about R style guide I would recommend looking at the following resource: https://style.tidyverse.org/

## RStudio
RStudio has many useful features which we have not covered. Let us remedy this and cover a few.

###Global options
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/global.png", auto_pdf = TRUE)
```

To get to the RStudio Global Options click "Tools" in the RStudio Toolbar, then from the drop down menu click "Global Options..". You should see something similar to the below:
```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/RStudio_global_options.png", auto_pdf = TRUE)
```

Have a look through the "General", "Code", and "Appearance" sections. The other sections are more advanced and I would suggets you ignore them currently.

Feel free to click on options in the "Appearance" section to see what they do. If you do not like your choices you can click the "Cancel" button to negate your recent choices and close the window. If you want to save your changes you can click the "Apply" button.

Also change the following for later.

1. Go to Global options.
2. Click on the "Code" section on the left.
3. Click on the "Completion" tab at the top.
4. Ensure "Show code completion:" is set to "Manually (Tab)"
5. Click "Apply" at the bottom followed by "OK".

This will be useful for tab completion which we will cover shortly.
```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/RStudio_manual_tab.png", auto_pdf = TRUE)
```

###Sweep buttons
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/sweep.png", auto_pdf = TRUE)
```
Sweep buttons allow you to sweep away items you no longer want in RStudio. There are two main sweep buttons, one for the __Console window__ and one for the __Environment pane__.

The sweep button for the __console window__ will clear all the text in the __console pane__. This is useful if you have filled the __console__ with lots of commands and __data frames__. This sweep button will not actually affect any of your work so do not be afraid to use it. The location of the sweep button is shown below.
```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/RStudio_console_sweep.png", auto_pdf = TRUE)
```

The sweep button for the __Environment pane__ is a bit more dangerous. This sweep button will clear all the objects from your environment. This will remove all the __variables__ you have created. This is not too bad if you have been using the __script editor__ to do your work as you can rerun all your commands to refill your environment. The location of the sweep button is shown below.
```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/RStudio_env_sweep.png", auto_pdf = TRUE)
```

##Multiplication table
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/multiplication.png", auto_pdf = TRUE)
```
Hopefully you'll find the above useful. We will learn some new __functions__ but before that let us create a quick __data frame__. You are going to make a multiplication table. The __data frame__ will be a 10 by 10 table with numbers one to ten as the row names and the column names. The value in each cell/index will be equal to the row name number times the column name number.

Before looking at the code below can you think of a way to do this?

The code below shows a method to create this __data frame__. I have tried to show you a variety of methods to create the __vectors__ below for demonstration purposes. Look at each command and make sure you understand how they work before continuing. In real life I would use one of these methods rather than many differnet methods.

__Tip__: If you double click a word/name in the __script editor__ it will highlight it. You can then start to type to replace the highlighted word.

```{r eval=FALSE}
#Vectors that will become columns
one <- 1:10
two <- one*2
three <- one+two
four <- seq(from = 4, to = 40, by = 4)
five <- (1:10)*5
six <- seq(from = 6, by = 6, length.out = 10)
seven <- one * (rep(x = 7, 10))
ate <- (1:80)[((1:80) %% 8) == 0]
nine <- one * (rep(x = 9, 10))
ten <- (seq(100,1000,100))/rep(10,10)
#Vector for row name
row_names <- c("one","two","three","four","five",
               "six","sefen","ate","nine","ten")
#Create data frame
multiplication_df <- data.frame(one, two, three,
                                four, five, six,
                                seven, ate, nine, ten,
                                row.names = row_names)
```

Have a look at the resulting __data frame__. You may have noticed that two of the row names and one of the column names is incorrect. We'll use the __functions__ `colnames()`and `row.names()` along with indexes and assignment to change these.
```{r eval=FALSE}
#Change the 8th column name ("ate") to "eight"
colnames(multiplication_df)[8] <- "eight"
#Change the 7th and 8th row names ("sefen" and "ate") to "seven" and "eight"
row.names(multiplication_df)[7:8] <- c("seven","eight")
```

##Tab complete
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/tab.png", auto_pdf = TRUE)
```
Tab completion is a very useful method when coding in any language. It takes some practice to get used to but it increases the speed of coding and drastically reduces typos. 

Before we continue, the tab key is the key above the "CAPS" key and left of the 'q' key. If you would like a demonstration of tab completion please ask!

The first way to tab complete is to tab complete file names. First set your working directory to the "Tea" directory in the "Week_4_files" directory you downloaded and unzipped for this week. Then you will run the below command. However, when your cursor is in the double quotes first press tab. This will hopefully show a dropdown of selections. There are two ways to then get to your choice:

1. Use the up and down arrow keys to move to the file name you want and then press enter to have the file name be autofilled.
2. Start typing your file name till it is the top choice of the drop down menu. You can then press enter to autofill the file name.

In this case tab complete should only show "tea_consumption.csv" as it is the only file in your working directory.

```{r eval=FALSE}
tea_df <- read.csv("tea_consumption.csv", check.names=FALSE)
```

You may notice that we only provided the file name and the `check.names=FALSE` for the `read.csv()` __function__. This is because of the format of the input file. In this case we do not want any of the input columns converted into row names. Additionally, the file was comma separated and the default separator to be used for `read.csv()` is commas. We will come back to this __data frame__ so either keep the __variable__ in your __environment__ or keep the __read__ code handy.

Let us __read__ in another file using tab complete to autofill the file name again. You will need to set your working directory to the "Lanuguage" directory in your "Week_4_files" directory first.

```{r eval=FALSE}
english_df <- read.csv("english_speaking_population_of_countries.txt", 
                   sep = "\t", 
                   row.names = 1,
                   check.names = FALSE)
```

Great!

The second way to use tab completion is to autofill __variable__ names, __function__ names and options. To autofill a __variable__ or __function__ name you can start typing the name then press tab to get the dropdown menu. 

Whilst in the `()` of a __function__ you can press tab to get a drop down menu of the option choices and press enter on the highlighted choice to autofill it. 

This only works if the name currently exists. I.e. you cannot autofill a __variable name__ if the __variable__ is not in your __environment__.

Continue using tab complete for the rest of the course. Practice makes perfect.

If you really don't like it you don't have to use it.

Data from above files:

- https://en.wikipedia.org/wiki/List_of_countries_by_tea_consumption_per_capita
- https://en.wikipedia.org/wiki/List_of_countries_by_English-speaking_population

##Tea
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/tea.png", auto_pdf = TRUE)
```
We will have a quick look at the "tea_df". This data shows the annual consumption of tea per capita with a rank based on the highest to lowest consumers.

Unfortunately the third column has the annual per capita consumption in kilograms (KG) and pounds (LB) with the two values seperated by a "_". Thankfully we can use the __function__ `gsub()` to fix this. 

`gsub()` will look for a specified pattern and replace it with a specified replacement.
`gsub()` is only to be used for __strings__.

Before fixing our __data frame__ I'll show you some examples of `gsub()`.
```{r eval=FALSE}
#Scalar string with mistake
sentence <- "The number 8 is spelt ate"
#gsub to print out line with mistake fixed
gsub(pattern = "ate", replacement = "eight", sentence)
#We can assign the scalar with the fix
sentence <- gsub(pattern = "ate", replacement = "eight", sentence)

#Vector with unwanted capital As
letter_vec <- c("A","Ab","Abc","Abcd")
#Replace pattern A with replacement a
letter_vec <- gsub(pattern = "A", replacement = "a", letter_vec)

#Vector with unwanted info after "_"
extra_info_vec <- c("A_some","B_nada","C_stuff","D_nill")
#Replace the _ and everything after it with nothing
#We signify this with ".*" which means any character (.) repeated zero or more times (*)
gsub(pattern = "_.*", replacement = "", extra_info_vec)

#What if we use gsub() with numerics?
gsub(pattern = 5, replacement = 2, 1:20)
#The output will be strings!
```

`.` and `*` are regular expressions. There are many regular expressions but we will only use `.*` to represent "all strings". The best part about this is we can put the `.*` after a specific character to replace the specific character and everything after it. Alternatively we can put the `.*` before a specific character to replace the specific character and everything before it.

Let us carry this out with the "tea_df" so it will hopefully make more sense. We are going to do this so we can make a kilogram column and a pound column.

__Note__: Make sure you have the "tea_df" in your environment before proceeding.
```{r eval=FALSE}
#Create a column for lb (pound). We'll copy the KG_LB_annual_per_capita column
tea_df$lb <- tea_df$KG_LB_annual_per_capita
#For the lb column we'll replace the "_" and everything before it with nothing
tea_df$lb <- gsub(pattern = ".*_", replacement = "", tea_df$lb)

#Change the column name KG_LB_annual_per_capita to kg
colnames(tea_df)[3] <- "kg"
#For the kg column we'll replace the "_" and everything after it with nothing
tea_df$kg <- gsub(pattern = "_.*", replacement = "", tea_df$kg)

#Since the columns initially contained "_" they are string columns
#Check if this is correct with the str() function
str(tea_df)
#Change the kg and lb columns to numerics
tea_df$kg <- as.numeric(tea_df$kg)
tea_df$lb <- as.numeric(tea_df$lb)
#Check with str() to see if it is now numerics
str(tea_df)
```

If you are interested in more regular expressions I would recommend looking at the following resources:

- https://r4ds.had.co.nz/strings.html#matching-patterns-with-regular-expressions
- https://rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf

##English speakers across the world
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/language.png", auto_pdf = TRUE)
```
Now we will do some processing of the "english_df" __data frame__. This shows the various number of english speakers with info on the number of those who have English as a first language and those who have it as an additional language. View the __data frame__ to see its contents.

There are a lot of NA values. Looking at the values in the __data frame__ try to figure out the two reasons that these NA values are present. Once you have had a thought you can have a look at the below two reasons.

1. Some countries have zero population of English first speakers and some countries have zero population of people who speak English as an additional language.
2. Some countries are missing data on the number of first and additional speakers, eg. Ukraine.

We will fix these issues one by one. First let us change all NAs to the number 0. The below method requires a lot of R knowledge to understand. I admit I do not fully understand it and I googled to find the answer. In this case the important part is that it works and it is a very short command.
```{r eval=FALSE}
english_df[is.na(english_df)] <- 0
```

We have changed all NAs. However, some of the rows in the 3rd and 4th column don't equal the 2nd column. We'll now remove these rows as they have missing data and we don't want that here.
```{r eval=FALSE}
#1st method with multiple lines for clarity
#Create a vector of first language + additional language
english_total_vec <- english_df[,3] + english_df[,"As an additional language"]
#Compare the column of total english speakers against the vector we created above
#This will create a logical vector (TRUE or FALSE)
english_total_logical_vec <- english_df$`Total English speakers` == english_total_vec
#Now create a new data frame by indexxing the english_df rows by the logical vector
#This will mean all TRUE rows will be kept and all FALSE rows will not be kept
english_complete_datasets_df <- english_df[english_total_logical_vec,]
#Remove the vectors we do not need anymore
rm(english_total_vec,english_total_logical_vec)

#2nd method is to carry out the above all in one command
english_complete_datasets_df_2 <- 
  english_df[
    (english_df$`As first language` + english_df$`As an additional language`) ==
      english_df$`Total English speakers`,
    ]

#We can compare our two created data frames with the identical() function
identical(english_complete_datasets_df,english_complete_datasets_df_2)
```

I would use the one command method but the multi line method is just as valid. It doesn't matter if your R code is not as compact as possible. The main things that matter are:

1. Your code works. When writing your own code make sure you test it with small datasets first so you know it is doing what you think it is doing.
2. Your code is well annotated. This will help with the first step and it will help your future self and others who will read your code.
3. You can read and understand your own code (annotation helps). There is little point in code you cannot read. You will most likely need to debug code you write (I know I do). Write code in a way that you know you will be able to read. If this means doing little parts over multiple lines then do it that way.

We will come back to the __data frames__ "tea_df" and "english_complete_datasets_df" for the exercises. But let us go onto 2 more topics.


##Identical
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/identikeys.png", auto_pdf = TRUE)
```
I touched on the `identical()` __function__ above to compare the two resulting __data frames__. `identical()` will compare two objects and if the objects are exactly identical it will print TRUE. If they are not exactly identical it will print FALSE. The function can be given __scalars__, __vectors__, __data frames__ etc. Below are some examples
```{r eval=FALSE}
identical(1,1)
identical(1,2)
identical("word","word")
identical("word","orb")
identical(1,"1")
identical("one",1)
identical(1:5,1:5)
identical(1:5,6:9)
identical(1:5,1:6)
identical(c("a","b"),c("a","b"))
identical(c("a","b"),c("c","b"))
identical(c("a","b"),c("b","a"))
identical(english_df,english_df)
identical(english_df,tea_df)
```

##Shortcuts
```{r, fig.align = 'center',out.width= '30%', echo=FALSE }
knitr::include_graphics(path = "figures/keyboard.png", auto_pdf = TRUE)
```
RStudio has many keyboard shortcuts for the __Script editor__. Some of these are common shortcuts used for other software and some are unique to RStudio. 

Below are a few:

- "Ctrl + a" : This will highlight all text in a __Script editor__ that your cursor is in. This is useful to run all your code by highlighting it all and then pressing "Ctrl + enter". Be careful though as if you starting typing when all the text is highlighted it will delete it all.
- "Ctrl + z" : This will undo your last typing action. You can undo your actions till the last time you saved your script. Very useful if you accidentally delete some text.
- "Ctrl + c" : Copy highlighted text.
- "Ctrl + p" : Paste text.
- "Ctrl + shift + c" : This will put a `#` at the start of each highlighted line. This is useful to annotate multiple lines at once. To unannotate the lines, highlight them again and use the shortcut.
- "Ctrl + f" : This will bring the search and replace menu at the top of the __Script editor__. 

There are a lot more shortcuts. If you want to see the full list go to "Tools" on the RStudio toolbar and then select "Keyboard Shortcuts Help"

Now time for exercises!

<!--chapter:end:10-Handy_tips_and_tricks.Rmd-->

# Week 4 exercises
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/exercises.png", auto_pdf = TRUE)
```

There has been a lot covered this week so these exercises will hopefully be straightforward.

Please use your "Exercises.R" script for this, using annotations and code sections to keep the contents clear and separated.

##Tea exercise
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/tea.png", auto_pdf = TRUE)
```

The first task you will carry out is printing out information from "tea_df". Below is an example statement for the country Turkey:

"Turkey is the number 1 consumer of tea. It consumes 5.8kg of tea annually per capita."

Print out this satement for the countries Ireland, United Kingdom, France, and Australia with their relevant information. Make sure the kilogram value only has one decimal place.

__Tip__: You will require the __functions__ `paste()` and `round()` from week 2 and 1.

##English speakers across the world exercise
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/language.png", auto_pdf = TRUE)
```
The last exercise is to create the following table as a __data frame__ called "english_100mil_df". Use the "english_complete_datasets_df" __data frame__ as a start.

```{r echo = FALSE, results = 'MSc_winter_term_df'}
library("knitr")
library(kableExtra)
english_df <- read.csv("english_speaking_population_of_countries.txt", 
                   sep = "\t", 
                   row.names = 1,
                   check.names = FALSE)
english_df[is.na(english_df)] <- 0
english_complete_datasets_df <- 
  english_df[
    (english_df$`As first language` + english_df$`As an additional language`) ==
      english_df$`Total English speakers`,
    ]
english_100mil_df <- english_complete_datasets_df[english_complete_datasets_df$`Eligible population` > 100000000,]
english_100mil_df$`Fraction of population that are English speakers` <- 
  english_100mil_df$`Total English speakers` /
  english_100mil_df$`Eligible population`
english_100mil_df["Mean",] <- colMeans(english_100mil_df)
english_100mil_df["Total",1:4] <- colSums(english_100mil_df[1:7,1:4])
english_100mil_df["Total","Fraction of population that are English speakers"] <- 
  english_100mil_df["Total","Total English speakers"] /
  english_100mil_df["Total","Eligible population"]

kbl(english_100mil_df) %>%
  scroll_box(width = "100%")
```


The __data frame__ only contains countries that have an eligible population that is greater than 100 million (100000000). Ensure the "Total" row was not calculated using the "Mean row".

When you have created yours check it with the above one. Is your value for the "Total" "Fraction of population that are English speakers" correct?.

Once you have created the __data frame__ __write__ it out as a comma separated file with the function `write.table()` called "English_top_7_populated_countries.csv". Have the row and column names surrounded by quotes in your file. Make sure there is an empty value above your row names.

##Extra exercise
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/multiplication.png", auto_pdf = TRUE)
```
If you still have time this session and you do not have any questions please attempt the following task:

Create a multiplication table like the one in the practice for this week. However have the row and column names equal one to twelve.

Then __write__ the __data frame__ to a file. The name and format of the file is up to you.

There is no solution to this in the next section.

<!--chapter:end:11-Week_4_exercises.Rmd-->

# Week 4 exercise solutions
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/answers.png", auto_pdf = TRUE)
```

##Tea solution
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/tea.png", auto_pdf = TRUE)
```
First ensure you have the "tea_df" loaded (remember your working directory will need to be in the correct location first). Also it needs to be preprocessed with the `gsub()` function.
```{r eval=FALSE}
tea_df <- read.csv("tea_consumption.csv", check.names=FALSE)
tea_df$lb <- tea_df$KG_LB_annual_per_capita
tea_df$lb <- gsub(pattern = ".*_", replacement = "", tea_df$lb)
colnames(tea_df)[3] <- "kg"
tea_df$kg <- gsub(pattern = "_.*", replacement = "", tea_df$kg)
tea_df$kg <- as.numeric(tea_df$kg)
tea_df$lb <- as.numeric(tea_df$lb)
```

Remember there are many ways to carry this out but here is one.

First create a __vector__ with the names of the countries we want:
```{r eval=FALSE}
countries <- c("Ireland", "United Kingdom", "France", "Australia")
```

Set the row names to the countries for easy indexxing:

__Note__: Row name must be unique which is the case here.
```{r eval=FALSE}
row.names(tea_df) <- tea_df$Country
```

Create a __data frame__ that only contains our countries of interest. We use the __vector__ as an index for the rows.
```{r eval=FALSE}
tea_df_subset <- tea_df[countries,]
```

Here because we are working with a temporary __variable__ we will overwrite the kg column so the values only contain one decimal place
```{r eval=FALSE}
tea_df_subset$kg <- round(x = tea_df_subset$kg, digits = 1)
```

Last step is to print out the statement. We will use `paste0()` which is exactly like `paste()` but the `sep =` option is set to `""`.
```{r eval=FALSE}
paste0(tea_df_subset$Country, " is the number ", tea_df_subset$Rank,
       " consumer of tea. It consumes ", tea_df_subset$kg, "kg of tea annually per capita.")
```

##English speakers across the world solution
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/language.png", auto_pdf = TRUE)
```

First make sure the __data frame__ is created. Remember to set your working directory to where the file is.
```{r eval=FALSE}
english_df <- read.csv("english_speaking_population_of_countries.txt", 
                   sep = "\t", 
                   row.names = 1,
                   check.names = FALSE)
english_df[is.na(english_df)] <- 0
english_complete_datasets_df <- 
  english_df[
    (english_df$`As first language` + english_df$`As an additional language`) ==
      english_df$`Total English speakers`,
    ]
```

Create new __data frame__ only containing countries with an eligible population of > 100 million.
```{r eval=FALSE}
english_100mil_df <- english_complete_datasets_df[
  english_complete_datasets_df$`Eligible population` > 100000000,
  ]
```

Create column with fraction of total english speakers against population
```{r eval=FALSE}
english_100mil_df$`Fraction of population that are English speakers` <- 
  english_100mil_df$`Total English speakers` /
  english_100mil_df$`Eligible population`
```

Create row with mean values
```{r eval=FALSE}
english_100mil_df["Mean",] <- colMeans(english_100mil_df)
```

Create row with totals
```{r eval=FALSE}
english_100mil_df["Total",1:4] <- colSums(english_100mil_df[1:7,1:4])
```

Create the total fraction of english speakers
```{r eval=FALSE}
english_100mil_df["Total","Fraction of population that are English speakers"] <- 
  english_100mil_df["Total","Total English speakers"] /
  english_100mil_df["Total","Eligible population"]
```


__Write__ the data as a file
```{r eval=FALSE}
write.table(x = english_100mil_df, 
            file = "English_top_7_populated_countries.csv", 
            col.names=NA,
            quote = TRUE, 
            sep = ",")
```


<!--chapter:end:12-Week_4_exercises_solutions.Rmd-->

# Week 5 - Plots: Histograms and Line graphs
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/palette.png", auto_pdf = TRUE)
```

This week we will learn how to create two different types of plots; Histograms and Line graphs. I have chosen these two types of plots first as they are relatively straightforward to create.

## Histogram
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/histogram.png", auto_pdf = TRUE)
```
A histogram consists of bars showing the frequency of variables present in numbered ranges (bins). This allows you to see an approximate distribution of numerical data.

We are starting with histograms as the __function__ `hist()`, which creates a histogram, only requires one __vector__. 

The following code creates a numerical __vector__ and then produces a histogram. When you run the `hist()` command a plot should appear in your __"Plots" pane__ of the __MISC window__.

```{r eval=FALSE}
numeric_vec <- 1:40
hist(numeric_vec)
``` 

You will notice that the histogram is not very interesting. There are 8 bars all of equal size. This is because we plotted the numbers from 1-40 so numbers 1-5 are counted in the first bar/bin, 6-10 in the second bar/bin and so forth. To get a more interesting histogram we will create a more interesting __vector__.

Histograms are good to see the numerical distribution of data. In this case we are going to look at the number of cities (with greater than 300,000 population) in EU countries (https://en.Wikipedia.org/wiki/List_of_cities_in_the_European_Union_by_population_within_city_limits).

The first step is to create a __vector__ with the numbers of cities in EU countries, however we won't know what countries these correspond to yet. Then we will create a histogram and set the colour of the bars with the option `col = `.
```{r eval=FALSE}
eu_cities <- c(1, 1, 3, 1, 2,
               2, 1, 1, 6, 22,
               2, 1, 1, 10, 1,
               1, 4, 9, 1, 7,
               1, 12, 3)
hist(eu_cities, col = "orange")
```

With that histogram we can see that most EU countries have 1-5 cities with a few having a much larger amount. As most of the time you will not be working with just __vectors__ let us make a __data frame__ containing the number of EU cities and the population of the EU countries.

The population numbers will be in millions to the closest 1 decimal place and consist of the 2020 Eurostat figures from: https://en.Wikipedia.org/wiki/List_of_European_Union_member_states_by_population

```{r eval=FALSE}
eu_country_names <- c("Austria", "Belgium", "Bulgaria", "Croatia", "Czech Republic", 
                      "Denmark", "Estonia", "Finland", "France", "Germany", 
                      "Greece", "Hungary", "Ireland", "Italy", "Latvia", 
                      "Lithuania", "Netherlands", "Poland", "Portugal", "Romania", 
                      "Slovakia", "Spain", "Sweden")
eu_pop <- c(8.9, 11.5, 7.0, 4.1, 10.7,
            5.8, 1.3, 5.5, 67.1, 83.2,
            10.7, 9.8, 5.0, 60.2, 1.9,
            2.8, 17.4, 38.0, 10.3, 19.3,
            5.5, 47.3, 10.3)
eu_df <- data.frame(eu_cities,eu_pop,
                    row.names = eu_country_names)
```

We will quickly create a histogram for the population numbers. We'll make the bar colours purple and we'll make the x axis label "2020 Eurostat population number in millions" with the `xlab = ` option.

```{r eval=FALSE}
hist(eu_df$eu_pop, col = "purple",
     xlab = "2020 Eurostat population number in millions")
```

We have a similar pattern as with the number of cities (most have low numbers, some high numbers). 

We can quickly check if the countries with the high number of cities also have the high populations by creating a new column equal to population / number of cities. This will give is nice ratios. We can plot the distribution of these ratios in a histogram.

For this histogram we will also add a title to the plot with the option `main = `. Additionally we will choose a different colour. Having different colours and main titles makes it easier for you to instantly know which plot you are looking at.

```{r eval=FALSE}
#Create ratio column
eu_df$pop_cities_ratio <- eu_df$eu_pop / eu_df$eu_cities
#Histogram of ratio distribution
hist(eu_df$pop_cities_ratio, col = "blue",
     xlab = "Ratio of population (millions) to numer of cities",
     main = "EU countries ratio of population to cities")
```

Looking at the plot most countries seem to have a ratio of 2-6 million citizens to every city. However, it is still not a perfect match with some lower and some higher ratios. Of course a result is a result and we have hopefully found out something new.

Before we go onto line graphs I'll show you how to look at your previous plots. In the __Plots pane__ of the __MISC window__ there are two arrows on the top left. You can use these to go backwards and forwards between the plots you have created since you opened RStudio. Give it a go!

```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/RStudio_plot_pane_arrows.png", auto_pdf = TRUE)
```

## Line graphs
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/line_graph.png", auto_pdf = TRUE)
```
Line graphs are perfect for showing change over time. Knowing this we'll go back to a data set we have touched before, the file "UK_retail.txt" from week 3. This file showed the success of four different retail sectors in the UK from September 2017 to September 2020.

### Read in data
First step is to set your working directory to the "Week_3_files" directory so you can then read in the data. Once the __data frame__ is created we will remove all non 2020 information.
```{r eval=FALSE}
retail_df <- read.csv("UK_retail.txt", sep = "\t", row.names = 1, check.names = FALSE)
retail_df <- retail_df[29:37,]
```

Before we continue have a look at the __data frame__ and make sure you are comfortable with what it contains. 

###Plotting a line graph
We are going to plot the entire information for the Food sector. We will use the __function__ `plot()` with the option `type = "l"`. This will produce a plot of type "line" (`"l"`).

This requires we provide a numeric __vector__ for the x axis (option `x = `) and the y axis (option `y = `). Currently our month and year information is in the row names as strings. 

Therefore before we plot the information we will create a new column called "time_point" with the numbers 1 to the number of rows. We will carry this out with the __function__ `nrow()` which produces one number equal to the number of rows in the specified __data frame__. 

We won't use it here but the __function__ `ncol()` is similar to `nrow()` but for the number of columns.

```{r eval=FALSE}
#Produce time_point column
retail_df$time_point <- 1:(nrow(retail_df))
#Produce line plot of the food sector over time point.
plot(y = retail_df$Food, retail_df$time_point, type = "l")
```

### Adding lines to a plot
This is looking decent but you normally want more than one line in a line graph. Thankfully we can do this with the __function__ `lines()`. We can add the other three sectors to the line graph like below:

__Tip__: Remember to use tab completion to auto fill __function__, __variable__, and column names as well as for __function__ options.
```{r eval=FALSE}
lines(y = retail_df$`Non-food`, x = retail_df$time_point)
lines(y = retail_df$`Non-store`, x = retail_df$time_point)
lines(y = retail_df$Fuel, x = retail_df$time_point)
```

We have created the line graph with all the sectors. However all the data is not visible.

### Axis limits
To fix this we need to make sure all the data is within the graph. When the `plot()` __function__ was run it created the y limits based on the Food sector which has a minimum and maximum value of 101.5 and 111.3. Unfortunately the other sectors barely fit in this range.

To prevent this issue we can use the `plot()` option of `ylim = `. This option is provided with a __vector__ of 2 numbers. The first number is where the y axis will start. The second number is where the y axis will end.

To find out where the y axis will end we will use the `max()` __function__. This will give one number which is equal to the highest number found in a numeric __object__. This __object__ can be a __scalar__, __vector__, or a __data frame__.

We will use the __function__ `min()` just like `max()` to find where the y axis should start.

Let us therefore recreate the plot with an appropriate y axis range.

__Note__: Some times it is more appropriate to set values for the y limits (i.e. starting the y axis at 0). In this case 100 is the baseline value so it would be inappropriate to start at 0.

__Tip__: Copying your past code in the script editor and editing it will make the following examples a lot quicker to carry out.
```{r eval=FALSE}
#Minimum and maximum for y axis
#Provide the function a subset of the retail_df
#so it is not using the time_point column
min_y <- min(retail_df[,1:4])
max_y <- max(retail_df[,-5])
#Produce line plot of the food sector over time point.
#Set y limits (min,max)
plot(y = retail_df$Food, retail_df$time_point, type = "l",
     ylim = c(min_y,max_y))
#Add lines
lines(y = retail_df$`Non-food`, x = retail_df$time_point)
lines(y = retail_df$`Non-store`, x = retail_df$time_point)
lines(y = retail_df$Fuel, x = retail_df$time_point)
```

Great! That is much better. We can now see that two lines fall after time_point 2 whilst one increases. 

### Axis labels
Numbers on the x axis are not ideal in this case. We will therefore use the `axis()` function to set our own x axis labels. We will use the following options for this:

- `1`: The first option to `axis()` indicates the location of the axis labels. `1` indicates they will be located on the x axis (below).
- `at = retail_df$time_point`: This indicates where the points tic marks will be drawn.
- `labels = row.names(retail_df)`: A character __vector__ for the labels to be placed at the tick marks.

For more info for `axis()` run the command `?axis` to see its help page.

To use the `axis()` __function__ correctly we need to make sure there are no preexisting labels and tick marks on the x axis or else the new labels will go on top of the old. To do this we provide the `plot()` __function__ with the option `naxt ='n'`, i.e. no x axis ticks.

```{r eval=FALSE}
#Produce line plot of the food sector over time point.
#Ensure x axis ticks and labels are not displayed
plot(y = retail_df$Food, retail_df$time_point, type = "l",
     ylim = c(min_y,max_y), xaxt = 'n')
#Add row names (month and date strings) as x axix labels
axis(1, at = retail_df$time_point, labels = row.names(retail_df))
#Add lines
lines(y = retail_df$`Non-food`, x = retail_df$time_point)
lines(y = retail_df$`Non-store`, x = retail_df$time_point)
lines(y = retail_df$Fuel, x = retail_df$time_point)
```

When the plot is generated there may be only some labels showing for the x axis. If you would like to show them all increase the size of the __MISC window__.

### Plot titles
Before we colour the lines different colours, let us add a main title and provided better x and y axis with better titles.
```{r eval=FALSE}
#Produce line plot of the food sector over time point.
#Add main, x, and y titles
plot(y = retail_df$Food, retail_df$time_point, type = "l",
     ylim = c(min_y,max_y), xaxt = 'n',
     main = "Performance of UK retail sectors over 2020",
     ylab = "Seasonally adjusted volume sales",
     xlab = "Month and Year")
#Add row names (month and date strings) as x axix labels
axis(1, at = retail_df$time_point, labels = row.names(retail_df))
#Add lines
lines(y = retail_df$`Non-food`, x = retail_df$time_point)
lines(y = retail_df$`Non-store`, x = retail_df$time_point)
lines(y = retail_df$Fuel, x = retail_df$time_point)
```

### Line colours
Next we will colour the lines differently to differentiate the retail sectors. We carry this out with the `col = ` options for `plot()` and `lines()`.
```{r eval=FALSE}
#Produce line plot of the food sector over time point.
#Include the colour red for the bars
plot(y = retail_df$Food, retail_df$time_point, type = "l",
     ylim = c(min_y,max_y), xaxt = 'n',
     main = "Performance of UK retail sectors over 2020",
     ylab = "Seasonally adjusted volume sales",
     xlab = "Month and Year",
     col = "red")
#Add row names (month and date strings) as x axix labels
axis(1, at = retail_df$time_point, labels = row.names(retail_df))
#Add lines with different colours
lines(y = retail_df$`Non-food`, x = retail_df$time_point, col = "blue")
lines(y = retail_df$`Non-store`, x = retail_df$time_point, col = "green")
lines(y = retail_df$Fuel, x = retail_df$time_point, col = "purple")
```

### Plot legend
We are almost there! The one thing we are missing now is a legend so we can quickly see what colour represents what sector.

This can be carried out by using the __function__ `legend()` after the plot is created. In this case the __function__ is run with the following options:

- `x = "topleft"`: The legend will be placed in the top left of the plot.
- `legend = colnames(retail_df[,1:4])`: This dictates the labels that will be in the legend.
- `col = c("red","blue","green","purple")`: This indicates the matching colours for the labels.
- `lty = 1`: This indicates that the colours will be presented as lines of type 1.

```{r eval=FALSE}
legend(x = "topleft",
       legend = colnames(retail_df[,1:4]),
       col = c("red","blue","green","purple"),
       lty = 1)
```

That is a good amount to go through. Therefore there is no exercise this week. If you have time read through the above again and possible try to create a histogram or line plot with one of the data sets from previous weeks.



<!--chapter:end:13-Plots_line_graphs_and_histograms.Rmd-->

# Week 6 - Plots: Scatter plots and Box plots
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/large_brush.png", auto_pdf = TRUE)
```

Last week we learnt how to make Histograms and Line graphs. This week it is Scatter plots and Box plots.

## Scatter plot
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/Scatterplot_2.png", auto_pdf = TRUE)
```

Scatter plots are a great way to compare two matching variables. To make a scatter plot we use the `plot()` __function__ again. This means a lot of what we went through last week will be helpful for this week.

### Basic examples
First we'll create a simple scatter plot plotting the numbers 1:20 against the same range of numbers times by 2. For this we provide the option `type = "p"` to indicate we want the data plotted as points.

```{r eval=FALSE}
plot(x = 1:20, y = (1:20)*2, type = "p")
``` 

That was a nice linear plot. We'll make a curve this time. 

In the command we will not include the option `type = "p"` as this is the default for `plot()`. 

Additionally we will not provide the option names `x = ` and `y = `. __Functions__ have an order to their options so if you leave out the option names but provide options (in this case __vectors__) it will use the options in the order. In the case of `plot()` it will take the first option as `x = ` and the second option as `y = `. It is common for plotting functions to take x first then y.

```{r eval=FALSE}
plot(1:20, (1:20)*(1:20))
```

### Animal sizes
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/blue_whale.png", auto_pdf = TRUE)
```
For our scatter plot from real data we will look at the sizes of the largest animals in the world. This data is from: https://en.Wikipedia.org/wiki/Largest_organisms

The data we will be using will contain the following information:

- Animal names
- Average mass in tonnes
- Maximum mass in tonnes
- Average total length in metres
- Group, In this case are they Mammals or Reptiles
- Biom, are they aquatic, semiaquatic, or terrestrial

The first step is to read in the data in the "Week_6_files" directory. We have included a new option: `stringsAsFactors = TRUE`. This is important for plotting and will be explained more later.

```{r eval=FALSE}
animal_df <- read.csv("animal_sizes.csv", 
                      row.names = 1, check.names = FALSE,
                      stringsAsFactors = TRUE
                      )
``` 

Check the column names with the __function__ `colnames()`. With these column names we can create some quick plots.

We'll compare the average and maximum weight
```{r eval=FALSE}
plot(x = animal_df$`Average mass (tonnes)`,
     y = animal_df$`Maximum mass (tonnes)`)
``` 

Average and maximum weight appear to correlate as expected.

Sometimes a quick and easy plot is all you want. If you're not going to present a plot then it doesn't need to be pretty. As long as it is functional it is useful.  

Now let's compare the average weight and length
```{r eval=FALSE}
plot(x = animal_df$`Average mass (tonnes)`,
     y = animal_df$`Average total length (m)`)
``` 

With that we can see the following:

- At lower weights (< 20 tonnes) a longer length does not necessarily mean a higher mass
- At higher weights (>20 tonnes) there appears to be an overall trend of longer lengths equaling higher masses with the animal with the highest mass having the longest length

However it is quite hard to see the overall trend in the lower mass animals as they are squashed in a small part of the plot. We can zoom into this part in two different ways

```{r eval=FALSE}
#First method is to set the x and y limits manually 
#This allows us to choose the specific part to zoom into
plot(x = animal_df$`Average mass (tonnes)`,
     y = animal_df$`Average total length (m)`,
     xlim = c(0,10), ylim = c(0,10))
#The other method is to subset the data
#so we only plot the data we want
plot(x = animal_df[animal_df$`Average mass (tonnes)` < 10,
                   "Average mass (tonnes)"],
     y = animal_df[animal_df$`Average total length (m)` < 10,
                   "Average total length (m)"])
#I personally prefer the x and y limit approach
```

We can also include the Biom metadata as an aesthetic in the plot
```{r eval=FALSE}
#Plot
plot(x = animal_df$`Average mass (tonnes)`,
     y = animal_df$`Average total length (m)`, 
     col = as.numeric(animal_df$Biom),
     pch = 1
     )
#Legend
legend(x = "bottomright", col = 1:nlevels(animal_df$Biom), 
       legend = levels(animal_df$Biom), pch = 1)
``` 

## Factors
The last command used a lot of __factors__.

__Factors__ are a new __class__! They are a combination of __String__ and __Numeric__. They are useful for categorical data where the same values will appear multiple times.

View the __data frame__ and then check its structure with `str()`. You should notice that the columns Group and Biom are __Factors__ with different amounts of __levels__. 

The Group column has 2 __levels__. Confirm this with the __function__ `levels()` which returns the levels and `nlevels()` which returns the number of __levels__.
```{r eval=FALSE}
levels(animal_df$Group)
nlevels(animal_df$Group)
```

What are __levels__? 

__Levels__ are the unique values in a __factor__. __Levels__ also store a matching number. This number determines the order of the levels. In the case of Group "Mammal" is assigned the number 1 and "Reptile" is assigned the number 2. This is because numbers are assigned to __Levels__ in alphabetical order by default.

The other part of a __factor__ is the __elements__. The __elements__ are the part of a __vector__ we are familiar with. Let us look at the __factor vector__
```{r eval=FALSE}
animal_df$Group
```

It looks just like a __character vector__ except there are no double quotes and the __levels__ are at the bottom.

However, the __elements__ are actually numbers! Each number is assigned a __string__ by the __level__. This means:

- The __factor__ only needs to store a number for each __element__ and then it stores each unique __level__ only once. This will take up less memory than storing a __string__ multiple times.
- A __factor__ can be used as a __numeric__ or a __string__. This is very useful for plotting.

If you don't understand __factors__ from that explanation that is fine. I find it is a hard concept to explain or understand. 

An analogy would be a map key. You could just write "town", "Mountain", "railroad", "Lake" over a map to say where everything is like below:
```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/town_words.png", auto_pdf = TRUE)
```

Compare this to our map with symbols and a key:
```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/town_symbols.png", auto_pdf = TRUE)
```

The key represents the __levels__ with our unique __strings__ corresponding to symbols (numbers). Instead of each string being stored on the map multiple times only the symbols (numbers) are.

Time for a more practical example with code. We will first create a __character vector__ then create a __factor__ from it with the __function__ `factor()`. We'll then see what we can do with a __factor__.
```{r eval=FALSE}
#Create a character vector
char_vec <- c("a","b","a","a","b","d","d","c")
#Attempt to convert it to a numeric
as.numeric(char_vec)
#As expected this does not work and will give NAs

#Create a factor vector from our previous character vector
factor_vec <- factor(char_vec)
#Look at the factor
#You will notice that even though d is present in an earlier element
#c is the 3rd level whilst d is the 4th level
#This is because levels are ordered alphabetically
factor_vec
#Convert to string
as.character(factor_vec)
#Convert to numeric
as.numeric(factor_vec)
```

We will get back to plotting soon but first I want to show you how to specify the order of __levels__. This is important as a lot of the time alphabetically is not wanted. One example is with months.
```{r eval=FALSE}
#Create a factor vector of months
#We'll only include the 1st 3 months for brevity
months_factor_vec <- factor(c("jan","jan","feb","jan","feb",
                     "feb","mar","jan","feb","mar"))
#Check the vector and you will notice feb is before jan in the levels
months_factor_vec
levels(months_factor_vec)
#Before reordering our factor we will create a vector string
#This will contain our levels in the order we want
#They must contain the same spelling as the existing levels
months_order_vec <- c("jan","feb","mar")
#We use the factor function on our factor
#But we include the option levels providing the ordered character vector
months_factor_vec <-factor(months_factor_vec, 
                           levels = months_order_vec)
#Check the factor now
months_factor_vec
levels(months_factor_vec)
```

Know let us make a nice scatter plot of the animal data with points coloured by Biom and shaped (`pch =`) by Group.
```{r eval=FALSE}
#Plot
plot(x = animal_df$`Average mass (tonnes)`,
     y = animal_df$`Average total length (m)`, 
     col = as.numeric(animal_df$Biom),
     pch = as.numeric(animal_df$Group),
     xlab = "Average mass in tonnes",
     ylab = "Average total length in metres",
     main = "The mass and length of the largest animals"
     )
#Legend for biom colours
legend(x = "bottomright", col = 1:nlevels(animal_df$Biom), 
       legend = levels(animal_df$Biom), pch = 1)
#Legend for group shapes
legend(x = "bottom", col = "black", 
       legend = levels(animal_df$Group), 
       pch = 1:nlevels(animal_df$Group))
``` 

Quite a complicated plot but now we can see:

- Mammals are larger than Reptiles
- Semiaquatic reptiles are larger than Aquatic and Terrestrial reptiles

Why do you think the above 2 points are true? Check out what specific animals are in the __data frame__ animal_df to confirm your thoughts or help to figure it out.

Hopefully that has helped you figure out what a __factor__ is. If not give it a break and let us do some more plots. Hopefully it will click a bit more over time.

If not some more tutorials are:
https://swcarpentry.github.io/r-novice-inflammation/12-supp-factors/index.html
https://www.tutorialspoint.com/r/r_factors.htm

Working with factors resource: https://departmentfortransport.github.io/R-cookbook/factors.html


## Box plot
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/boxplot.png", auto_pdf = TRUE)
```

Next we are going to make a box plot with some Penguin data from:
https://allisonhorst.github.io/palmerpenguins/

This data contains information on individual penguins that were gathered from Palmer Station LTER. 

As you expect the first step is to read in the file. . The file is "penguin.txt" in the "Week_6_files" directory. This time it is a tsv (tab separated file) with no row names. We will make sure that columns containing strings will be converted to __factors__.
```{r eval=FALSE}
penguin_df <- read.csv("penguin.txt", 
                      check.names = FALSE,
                      stringsAsFactors = TRUE,
                      sep = "\t"
                      )
```

Each row is a measurement of a penguin. The columns for this __data frame__ are:

- species: Species of Penguin
- island: Island the Penguin was found on
- bill_length_mm: The bill length of the Penguin in millimetres
- bill_depth_mm: The bill depth of the Penguin in millimetres
- flipper_length_mm: The flipper length of the Penguin in millimetres
- body_mass_g: Weight of Penguin in grams
- sex: female or male
- year: Year the measurement was carried out in

With all that information we'll make a nice boxplot to show the body mass against the species.

The __function__ `boxplot()` can be used with this. This __function__ is different than the others where the first option is `yaxis_column_name~xaxis_column_name`. This is followed by the option `data = ` where you provide the __data frame__.

Below is the command for this:
```{r eval=FALSE}
boxplot(body_mass_g~species, data = penguin_df)
```

What is we want to split the 3 box plots into sex? 

We can do that like below:
```{r eval=FALSE}
boxplot(body_mass_g~species*sex, data = penguin_df,
        col = c("yellow","green"))
```

I will show you some more examples followed by a final nice plot.

x axis = island, y axis = flipper length
```{r eval=FALSE}
boxplot(flipper_length_mm~island, data = penguin_df)
```

x axis = island, y axis = bill depth
```{r eval=FALSE}
boxplot(bill_depth_mm~island, data = penguin_df)
```

x axis = bill length, y axis = species and sex
```{r eval=FALSE}
boxplot(bill_length_mm~species*sex, data = penguin_df)
```

What happens if we try to plot a __factor__ on the y axis?
```{r eval=FALSE}
boxplot(island~species*sex, data = penguin_df)
```
It does not work as an object with __class__ __factor__ can not be added to the x axis __object__.

What about a numeric to the x axis?
```{r eval=FALSE}
boxplot(flipper_length_mm~year, data = penguin_df)
```
That works and looks good because it is a discrete set of numbers. In fact you can have a __factor__ where the __levels__ are numerics. If you do this make sure it is a discrete set of numbers.

What if we use a continuous set of numbers?
```{r eval=FALSE}
boxplot(body_mass_g~bill_length_mm , data = penguin_df)
```
This does work! However, a scatter plot would most likely be a lot more suited to plotting this data.

We will now make one final plot for this section. I will not explain what the code is doing. Instead read and run the code to figure it out.
```{r eval=FALSE}
boxplot(body_mass_g~species*year , 
        data = penguin_df, 
        col = c("white","grey","orange"),
        main = "Mass of different Penguin species for 2007 - 2009",
        xlab = "Species and year",
        ylab = "Body mass in grams")
```

## Saving a plot to a file
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/r_save.png", auto_pdf = TRUE)
```
To save a plot to a file you can use the __functions__ `png()` and `dev.off()`.

The __function__ `png()` goes before all the plotting commands. It has various options but the ones we will use are:

-`filename =`: Provide this with a string that will be the file filename of the resulting file.
-`units =`: The units the width and height will be in. the default is "px" for pixels but I like to go for "mm" for millimetres.
-`width =`: The width of the plot in the file.
-`height =`: The height of the plot in the file.
- `res =`: Resolution of the plot. Usually a number between 50 and 300 with 300 being better quality. This number referes to dpi (dots per inch). 

After the `png()` and plotting __functions__ you use the __function__ `dev.off()`. This lets R know you are finished plotting and so the file from `png()` will be created.

You can then look at the plot. If it is not how you would like you can edit the script and rerun from `png()` to `dev.off()`. Through trial and error you can make the plot look how you like.

Let us save the last plot as a png file:
```{r eval=FALSE}
png(filename = "penguin_species_and_year_against_mass.png",
    units = "mm", width = 50, height = 50, res = 150)
boxplot(body_mass_g~species*year , 
        data = penguin_df, 
        col = c("white","grey","orange"),
        main = "Mass of different Penguin species for 2007 - 2009",
        xlab = "Species and year",
        ylab = "Body mass in grams")
dev.off()
```

Looking at the plot we made the width and height way too small. Therefore let us edit the width and height and then run it again.

__Note__: You will need to close and open the file after running the command to see the new plot.
```{r eval=FALSE}
png(filename = "penguin_species_and_year_against_mass.png",
    units = "mm", width = 250, height = 250, res = 150)
boxplot(body_mass_g~species*year , 
        data = penguin_df, 
        col = c("white","grey","orange"),
        main = "Mass of different Penguin species for 2007 - 2009",
        xlab = "Species and year",
        ylab = "Body mass in grams")
dev.off()
```

That overall is much better. But we cannot see all the labels on the x axis. Therefore let us make it wider.
```{r eval=FALSE}
png(filename = "penguin_species_and_year_against_mass.png",
    units = "mm", width = 400, height = 250, res = 150)
boxplot(body_mass_g~species*year , 
        data = penguin_df, 
        col = c("white","grey","orange"),
        main = "Mass of different Penguin species for 2007 - 2009",
        xlab = "Species and year",
        ylab = "Body mass in grams")
dev.off()
```

Super! You can save plots in other file formats and there ar emore options. Check them out with `?png`.

I hope you are ready to make more plots with the Penguin data because it is time for some exercises.

<!--chapter:end:14-Plots_scatterplot_and_box_plots.Rmd-->

# Week 6 exercises
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/penguin.png", auto_pdf = TRUE)
``` 
These exercises will primarily use the "penguin_df" from the theory and practice session.

Please use your "Exercises.R" script for this exercise as normal. Ensure you are using annotations and code sections to keep the contents clear and separated.

For convenience the code to load the __data frame__ from the directory "Week_6_files" directory is:
```{r eval=TRUE}
penguin_df <- read.csv("penguin.txt", 
                      check.names = FALSE,
                      stringsAsFactors = TRUE,
                      sep = "\t"
                      )
```

Your plots might not look exactly the same. As long as your plot contains the same data it is good. If you ar enot sure if your plot is correct, feel fre to look at the solutions to look at my code.

## Line graph
First we will ignore "penguin_df".

Create the below plot. You will need to create the __vectors__ yourself.
```{r eval=TRUE, echo=FALSE}
plot(x = rep(1:10, 2), 
     y = seq(from = 0.5, to = 10, by = 0.5),
     col = "red",
     main = 'A line graph with "red" as the colour',
     type = "l")
```

__Tip__: The x and y labels may help you figure out the commands to create the __vectors__.

## Histogram
From the "penguin_df" create the below plot:

__Note__: The colour of the bars are "blue".
```{r eval=TRUE, echo=FALSE}
#Create data frame with only the Penguins from Torgersen
penguins_torgensen_df <- penguin_df[penguin_df$island == "Torgersen",]
#Create a column with body mass in kilograms
penguins_torgensen_df$body_mass_kg <- 
  penguins_torgensen_df$body_mass_g / 1000
#Plot the histogram
hist(penguins_torgensen_df$body_mass_kg,
     main = "Histogram of the body mass of Penguins from Torgersen Island",
     xlab = "Body mass in kilograms",
     ylab = "frequency",
     col = "blue")
```

## Scatterplot
From the "penguin_df" create the below plot:

__Note__: You can check what numbers refer to what shape for `pch =` at: http://www.sthda.com/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r
```{r eval=TRUE, echo=FALSE}
#Create data frame with only the Penguins from 2009
penguin_2009_df <- penguin_df[penguin_df$year == "2009",]
#Produce plot
plot(x = penguin_2009_df$bill_length_mm,
     y = penguin_2009_df$bill_depth_mm,
     col = as.numeric(penguin_2009_df$species),
     main = "Penguin bills vs depth in 2009",
     xlab = "Bill length (mm)",
     ylab = "Bill depth (mm)",
     pch = 15)
#Create legend
legend(x = "bottomleft", 
       col = 1:nlevels(penguin_2009_df$species),
       legend = levels(penguin_2009_df$species),
       pch = 15)
```

Before you continue save this plot. Details below:

- Save the file as a png called "Penguins_2009_bill_depth_vs_length_scatterplot.png"
- Save the plot with a width and height of 250 and resolution of 150

## Boxplot
From the "penguin_df" create the below plot:

__Note__: Make sure the x axis is in the same order as below.
```{r eval=TRUE, echo=FALSE, fig.width= 12}
#Produce boxplot
boxplot(flipper_length_mm~sex*species,
        data = penguin_df,
        col = c("yellow","green"),
        main = "Flipper length of different species",
        xlab = "Species and sex of Penguin",
        ylab = "Flipper length (mm)"
)
```

For the last thing save this plot. Details below:

- Save the file as a jpg called "Penguins_species_and_flipper_length_boxplot.jpg"
- Save the plot with a width and height of 250 and resolution of 150


<!--chapter:end:15-Week_6_exercises.Rmd-->

# Week 6 exercise solutions
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/penguin_solutions.png", auto_pdf = TRUE)
``` 

## Line graph solution
Below is the code and the plot:
```{r eval=TRUE}
#Produce the plot with vectors created inside the function
plot(x = rep(1:10, 2), 
     y = seq(from = 0.5, to = 10, by = 0.5),
     col = "red",
     main = 'A line graph with "red" as the colour',
     type = "l")
```

## Histogram solution
Below is the code and the plot:
```{r eval=TRUE}
#Create data frame with only the Penguins from Torgersen
penguins_torgensen_df <- penguin_df[penguin_df$island == "Torgersen",]
#Create a column with body mass in kilograms
penguins_torgensen_df$body_mass_kg <- 
  penguins_torgensen_df$body_mass_g / 1000
#Plot the histogram
hist(penguins_torgensen_df$body_mass_kg,
     main = "Histogram of the body mass of Penguins from Torgersen Island",
     xlab = "Body mass in kilograms",
     ylab = "frequency",
     col = "blue")
```

## Scatterplot solution
Below is the code and the plot:
```{r eval=TRUE}
#Create data frame with only the Penguins from 2009
penguin_2009_df <- penguin_df[penguin_df$year == "2009",]
#Produce plot
plot(x = penguin_2009_df$bill_length_mm,
     y = penguin_2009_df$bill_depth_mm,
     col = as.numeric(penguin_2009_df$species),
     main = "Penguin bills vs depth in 2009",
     xlab = "Bill length (mm)",
     ylab = "Bill depth (mm)",
     pch = 15)
#Create legend
legend(x = "bottomleft", 
       col = 1:nlevels(penguin_2009_df$species),
       legend = levels(penguin_2009_df$species),
       pch = 15)
```

To save the plot the code is:
```{r eval=FALSE}
#Create data frame with only the Penguins from 2009
penguin_2009_df <- penguin_df[penguin_df$year == "2009",]
#Start png function
png(filename = "Penguins_2009_bill_depth_vs_length_scatterplot.png",
    units = "mm", height = 250, width = 250, res = 150 )
#Produce plot
plot(x = penguin_2009_df$bill_length_mm,
     y = penguin_2009_df$bill_depth_mm,
     col = as.numeric(penguin_2009_df$species),
     main = "Penguin bills vs depth in 2009",
     xlab = "Bill length (mm)",
     ylab = "Bill depth (mm)",
     pch = 15)
#Create legend
legend(x = "bottomleft", 
       col = 1:nlevels(penguin_2009_df$species),
       legend = levels(penguin_2009_df$species),
       pch = 15)
#Save file
dev.off()
```

## Boxplot solutions
Below is the code and the plot:
```{r eval=TRUE, echo=TRUE, fig.width= 12}
#Produce boxplot
boxplot(flipper_length_mm~sex*species,
        data = penguin_df,
        col = c("yellow","green"),
        main = "Flipper length of different species",
        xlab = "Species and sex of Penguin",
        ylab = "Flipper length (mm)"
)
```

To save the plot the code is:
```{r eval=FALSE}
#Start png function
jpeg(filename = "Penguins_species_and_flipper_length_boxplot.jpg",
    units = "mm", height = 250, width = 250, res = 150 )
#Produce boxplot
boxplot(flipper_length_mm~sex*species,
        data = penguin_df,
        col = c("yellow","green"),
        main = "Flipper length of different species",
        xlab = "Species and sex of Penguin",
        ylab = "Flipper length (mm)"
)
#Save file
dev.off()
```

<!--chapter:end:16-Week_6_exercises_solutions.Rmd-->

# Week 7 - Basic stats
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/basic_stats.png", auto_pdf = TRUE)
``` 

This week we'll learn how to carry out some basic stats. This will involve linear regressions and some t-tests.

Before we continue just a reminder about annotations and code sections.

## Linear regression
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/linear_regression.png", auto_pdf = TRUE)
``` 
Linear regression is a method to model the relationship between two __numeric vectors__. Ultimately we want to produce the predictive equation:

- _y = mx + c_

Where _m_ is equal to the gradient and _c_ is equal to the intercept. With this we can predict the value of _y_ if we know the value of _x_ and vice versa.

### Fish market dataset
```{r, fig.align = 'center',out.width= '30%', echo=FALSE }
knitr::include_graphics(path = "figures/bream.png", auto_pdf = TRUE)
``` 
Before getting to the analysis we need to read in the data. For this section we will be looking at information of 7 common fish species sold in Fish markets (Source: https://www.kaggle.com/aungpyaeap/fish-market).

The columns for the data are:

- __Species__: Species of fish ("Bream", "Roach", "Whitefish",
"Parkki", "Perch", "Pike", and "Smelt").
- __Weight__: Weight of the fish in grams.
- __Length1__: Vertical length of the fish in centimetres.
- __Length2__: Diagonal length of the fish in centimetres.
- __Length3__: Cross length of the fish in centimetres.
- __Height__: Height of the fish in centimetres.
- __Width__: Diagonal width of the fish in centimetres.

The dataset is primarily interested in predicting the weight of a fish based on its length, height, or width.

First step is to read in the data (in directory __"Week_7_files"__):
```{r eval=FALSE}
fish_df <- read.csv("Fish.csv", check.names = FALSE)
```

Have a look at the __data frame__ and you'll see it looks pretty good with no `NA` values.

For now we only want to look at the information for the species Bream. Let's create a "bream_df":
```{r eval=FALSE}
#Create the data frame
bream_df <- fish_df[fish_df$Species == "Bream",]
#Check how many rows it has
nrow(bream_df)
```

We are left with 35 data points which should be plenty for our linear regression.

### Scatterplot
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/Scatterplot_2.png", auto_pdf = TRUE)
``` 
Before we carry out the linear regression we'll create a scatterplot of the two __vectors__ we want to compare. For the first instance we will compare __Height__ to __Length1__ (vertical length).

In fact before we do, let's change the column name "Length1" to "v_length" so it is a bit more intuitive for us. Whilst we are at it we'll change the other length column names.
```{r eval=FALSE}
colnames(bream_df)[3:5] <- c("v_length", "d_length", "c_length")
```

Time to quickly plot "v_length" (x) against "Weight" (y):
```{r eval=FALSE}
plot(x = bream_df$v_length, y = bream_df$Weight)
```

Super! That looks like a decently linear plot with a positive trend. We will therefore fit the linear model.

### Linear model
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/lm.png", auto_pdf = TRUE)
``` 
We can fit a linear model with the __function__ `lm()`. We simply provide the column names as a formula ( `y_column_name ~ x_column_name` ) similar to the `boxplot()` __function__.

```{r eval=FALSE}
fit <- lm(Weight~v_length, data=bream_df)
```

We can now add the linear model as a line to our plot with the __function__ `abline()`
```{r eval=FALSE}
abline(fit)
```

With the line added we also want to add the linear equation to the plot. To do this we need to check the contents of the "fit" __variable__ first so we know what to add.
```{r eval=FALSE}
fit
```

You'll see the following two sections:

- `Call:` Shows the __function__ with options you ran to create "fit"
- `Coefficients:`: This contains 2 parts
    - `(Intercept)`: This is the intercept value of the linear model (_c_)
    - `v_length`: This is the gradient values (_m_)

Our next step is to create a __string scalar__ containing the linear equation. To do this we can extract the coefficients from the "fit" __object__ like below:
```{r eval=FALSE}
m <- fit$coefficients[2]
c <- fit$coefficients[1]
```

If you print out "m" and "c" to the console you'll notice they have a different number of decimal places than when displayed through printing "fit". We will therefore change these to 2 decimal places with the `round()` __function__:
```{r eval=FALSE}
m <- round(m, digits = 2)
c <- round(c, digits = 2)
```

Now to use the `paste0()` __function__ to create our linear equation as a __string scalar__:
```{r eval=FALSE}
linear_equation <- paste0("y = ", m , "x + ", c)
```

Finally we will recreate our plot, add the abline, and then add the linear equation. We will add the linear equation with the __function__ `text()`:
```{r eval=FALSE}
plot(x = bream_df$v_length, y = bream_df$Weight)
abline(fit)
text(x = 30, y = 800, labels = linear_equation)
```

The `text()` options `x = ` and `y =` normally require a bit of trial and error to set it in a nice location. This can be a bit fiddly but is made much easier by making the label smaller (e.g. making the numbers have a smaller amount of decimal places).

## t-test
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/scale.png", auto_pdf = TRUE)
```
A t-test can be used to determine if there is a significant difference between the means of two groups.

In this example we will compare the weights of the fish Bream, Parkki, and Roach. Therefore let's subset our __data frame__ so we have three __data frames__, one for each species.

We already have a "bream_df" so we only need to make one for Parkki and one for Roach. Before we do we'll change the column names for "fish_df" like we did for "bream_df"
```{r eval=FALSE}
colnames(fish_df)[3:5] <- c("v_length", "d_length", "c_length")
parkki_df <- fish_df[fish_df$Species == "Parkki",]
roach_df <- fish_df[fish_df$Species == "Roach",]
```

### Boxplot
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/boxplot.png", auto_pdf = TRUE)
```
Before carrying out a t-test it can be useful to visualise the difference between groups with a boxplot.

Before we do this we need to combine the three __data frames__ into one. This can be done by binding the rows with `rbind()`. This will combine two provided __data frames__ which contain the same number of columns with the same column names.
```{r eval=FALSE}
#Combine bream_df and parkki_df
fish_subset_df <- rbind(bream_df, parkki_df)
#Now rbind roach_df to our new df
fish_subset_df <- rbind(fish_subset_df, roach_df)
```

There is also `cbind` to combine __data frames__ by columns. In this case the __data frames__ need to have the same number of rows with the same order and names.

Time for a boxplot!
```{r eval=FALSE}
boxplot(Weight~Species, data = fish_subset_df)
```

We can clearly see that the weights of Parkki and Roach are very similar to each other but very different to Bream's weight.

### t-test comparison
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/five_percent.png", auto_pdf = TRUE)
```
Let us see if what we see visually is also visible statistically.

We can carry out a t-test with the __function__ `t.test()`. Simply provide the __function__ with the two __numerical vectors__ you would like to compare.
```{r eval=FALSE}
bream_parkki_ttest <- t.test(bream_df$Weight, parkki_df$Weight)
bream_roach_ttest <- t.test(bream_df$Weight, roach_df$Weight)
parkki_roach_ttest <- t.test(parkki_df$Weight, roach_df$Weight)
```

Print the resulting __variables__ to the console and you will see a lot of information. I am sure all these values can say a lot about the data but we are only interested in the p-values.

In this case we can say the means between the two groups tested are significantly different if the p-value is less than 0.05 (1 in 20).

It can be a bit annoying to have to look through the `t.test()` output for each result so we'll create a __vector__ to contain the p-values for comparisons against Bream.
```{r eval=FALSE}
fish_species_weight_ttests <- c(
  bream_parkki_ttest$p.value,
  bream_roach_ttest$p.value
)
```

This is pretty useful but we can't immediately see which comparison each t-test is equal to. Thankfully just like __data frames__ have row and column names, __vectors__ can have names for each element.
```{r eval=FALSE}
#Add the vector names
names(fish_species_weight_ttests) <- 
  c("bream_vs_parkki","bream_vs_roach")
#Look at the vector with the added names
fish_species_weight_ttests
```

We can then index the __vector__ through the names.
```{r eval=FALSE}
#Access the p-value of Bream against Roach
fish_species_weight_ttests["bream_vs_roach"]
#Add the p-value of Parkki against Roach
fish_species_weight_ttests["parkki_vs_roach"] <- 
  parkki_roach_ttest$p.value
```

With our nice __vector__ of p-values we can quickly see where the p-value is less than 0.05 (i.e. the means are significantly different) and where it is higher (i.e. the means aren't significantly different).
```{r eval=FALSE}
fish_species_weight_ttests < 0.05
```

Do these p-values match what you saw in the boxplot?

## Some more useful functions
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/r_toolbox.png", auto_pdf = TRUE)
```

### Summary
The __function__ `summary()` can give you some quick summary information for each column of a __data frame__.

```{r eval=FALSE}
summary(fish_df)
```

This gives you some nice information for your numerical columns:

- `Min.`: The minimum number
- `1st Qu.`: The 25th quartile
- `Median`: The median (Middle sorted number)
- `Mean`: The average
- `3rd Qu.`: The 75th quartile
- `Max.`: The maximum number 

You will notice the information given for the "Species" column is not very informative as it is a __character__ column. However, this would be a lot more descriptive if it was a __factor__.

Therefore we'll change the "Species" column to a __factor__ and run `summary()` again.
```{r eval=FALSE}
fish_df$Species <- as.factor(fish_df$Species)
summary(fish_df)
```

Now `summary()` shows how many instances of each species is present in the __data frame__.

For future cases it may better to use `stringsAsFactors = TRUE` with the `read.csv()` __function__ when we first read in the file.

### Table
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/table_ikea.png", auto_pdf = TRUE)
```
The `table()` __function__ will provide a __vector__ containing the number of instances for each __level__ in a __factor__. This is pretty much what `summary()` did to a __factor__.

However, unlike `summary()` it will also do this for __characters__ and __numerics__.

__Note__: Remember to use the __"Help"__ pane if you are not sure what a __function__ does.
```{r eval=FALSE}
#Table command for columns from fish_df
table(fish_df$Species)
table(as.character(fish_df$Species))
table(fish_df$Height)
table(floor(fish_df$Height))
table(as.integer(fish_df$Height))
#Run table on various numeric vectors
table(1:10)
table(1:100 * 0)
table(1:100 %% 2)
table(seq(from = 0, to = 50, by = 0.5) %% 7.5)
table(c(1:9,1:8,1:7,1:6,1:5,1:4,1:3,1:2,1))
#Table will run on logicals too
table(1:100 > 50)
table(c("a","a","b","c") == "a")
#Create a vector of 20 random numbers between 0 and 10
random_num_vec <- sample(0:10, size = 20, replace = TRUE )
#table
table(random_num_vec)
#Create a character vector randomly containing 1-10 of the strings
#"Book", "TV", and "Film" each
random_char_vec <- c(
  rep("Book", sample(1:10, size = 1)),
  rep("TV", sample(1:10, size = 1)),
  rep("Film", sample(1:10, size = 1))
)
#Now for table()
table(random_char_vec)
#Can create a quick bar plot with the output from table()
barplot(table(random_char_vec))
```

A few more __functions__ were introduced above. I will let you explore them yourself or you can ask me verbally.

## Further resources
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/resources.png", auto_pdf = TRUE)
```
Below are some further resources you can check that will help if you want to do some other plots and figures.

__Quick-R__: https://www.statmethods.net/index.html

__R Cookbook__: https://rc2e.com/



<!--chapter:end:17-Basic_stats.Rmd-->

# Week 7 exercises

## World happiness report
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/world_happiness.png", auto_pdf = TRUE)
``` 

### Data
For this exercise we will be looking at the World Happiness Report for 2016. This report is a survey of the state of global happiness. 

Source: https://www.kaggle.com/unsdsn/world-happiness?select=2016.csv

The columns for the data are:

- __Country__: Name of the country.
- __Region__: Region the country belongs to.
- __Happiness Rank__: Rank of the country based on the Happiness Score.
- __Happiness Score__: A metric measured in 2016 by asking the sampled people the question: "How would you rate your happiness on a scale of 0 to 10 where 10 is the happiest".
- __Lower Confidence Interval__: Lower Confidence Interval of the Happiness Score.
- __Upper Confidence Interval__: Upper Confidence Interval of the Happiness Score.
- __Economy (GDP per Capita)__: The extent to which GDP contributes to the calculation of the Happiness Score.
- __Family__: The extent to which Family contributes to the calculation of the Happiness Score.
- __Health (Life Expectancy)__: The extent to which Life expectancy contributed to the calculation of the Happiness Score.
- __Freedom__: The extent to which Freedom contributed to the calculation of the Happiness Score.
- __Trust (Government Corruption)__: The extent to which Perception of Corruption contributes to Happiness Score.
- __Generosity__: The extent to which Generosity contributed to the calculation of the Happiness Score.
- __Dystopia Residual__: The extent to which Dystopia Residual contributed to the calculation of the Happiness Score. More info in the "What is Dystopia?" section at https://worldhappiness.report/faq/.

### Tasks & questions
With that information carry out the following tasks and answer the questions:

1. Read in the file "world_happiness_report_2016" as __data frame__ called "happy_df". Ensure __strings__ are read in as __factors__ and that none of the columns are read in as row names.
2. Answer the following questions using the output from one __function__:
    + How many countries are in the region "Western Europe"?
    + What is the maximum number in the "Happiness Score" column?
    + From the columns "Economy (GDP per Capital)" to "Dystopia Residual", which has the highest mean and which has the lowest?
3. Create the below plot.
    + The equation does not have to be in exactly the same position as the below. Just make sure it is all clearly visible, it contains the same text, and it is not on top of any points.
    + The colour for the line is "mediumslateblue"
    + Note you can put "\n" into a label/title to make a new line.
    + e.g "This is the first line \n and this is the second line"
```{r eval=TRUE, echo=FALSE, fig.width= 8, fig.height=8}
#Read in df
happy_df <- read.csv("world_happiness_report_2016.csv", 
                      check.names = FALSE,
                      stringsAsFactors = TRUE,
                      sep = ","
                      )
#Fit linear model of Economy (x) against Family (y)
fit_economy_family <- 
  lm(Family~`Economy (GDP per Capita)`, data = happy_df)
#Create string for linear equation
c <- round(fit_economy_family$coefficients[1], digits = 4)
m <- round(fit_economy_family$coefficients[2], digits = 4)
lm_equation <- paste0("y = ", m , "x + ", c)
#Produce plot
plot(x = happy_df$`Economy (GDP per Capita)`,
     y = happy_df$Family,
     main = "Comparison of the effect of \n Economy and Family on happiness",
     xlab = "Economy (GDP per Capita)",
     ylab = "Family",
     pch = as.numeric(happy_df$Region),
     xlim = c(0,2), ylim = c(0,1.5),
     col = 1)
#Add abline
abline(fit_economy_family, col = "mediumslateblue")
#Add equation to top right
text(x = 0.4, y = 1.1, labels = lm_equation)
#Add the legend
legend(x = "bottomright",
       pch = 1:nlevels(happy_df$Region),
       legend = levels(happy_df$Region))
```

4. It may be a bit awkward to get the right size for the plot in the __"Plots"__ pane. Therefore save it as a png file with the following options:
    + File name of "Economy_vs_family.png"
    + Dimensions of file is 8 inches for height and width
    + Resolution of 200
    
5. Answer the following questions using information on the line graph and the linear model.
    + Does the linear model have a positive or negative gradient?
    + Which variable (Economy or Family) has higher values?
    + If the value of Economy was 2.1 what would be the predictive value of Family according to the linear model equation?
    + Which region appears to have the highest values for Economy and for Family?
    
6. Create the following boxplot.
    + You can change the the levels with the following code
```{r eval=FALSE}
short_region_names <- 
  c("OZ_n_NZ", "C_n_E_Europe", "E_Asia", "L_America_n_Caribbean",
    "Middle_E_n_N_Africa", "N_America", "SE_Asia", "S_Asia",
    "Sub_Saharan", "W_Europe")
levels(happy_df$Region) <- short_region_names
```
   
```{r eval=TRUE, echo=FALSE, fig.width= 16, fig.height=10}
#Change level names
short_region_names <- 
  c("OZ_n_NZ", "C_n_E_Europe", "E_Asia", "Latin_A_n_Carib",
    "ME_n_N_Africa", "N_America", "SE_Asia", "S_Asia",
    "Sub_Saharan", "W_Europe")
levels(happy_df$Region) <- short_region_names
#Create boxplot
boxplot(`Happiness Score`~Region, data = happy_df, 
        ylim = c(0,10),
        col = 1:nlevels(happy_df$Region),
        main = "Happiness scores across regions"
)
```

7. Save the above as a jpeg called "Region_happiness_boxplots.jpg" with a width of 1500 pixels and a height of 750 pixels.

8. Last task! Carry out t-tests on the following comparisons for Happiness Score and determine if the means are significantly different.
    + West Europe and North America
    + West Europe and South Asia
    + South Asia and South Eastern Asia

<!--chapter:end:18-Week_7_exercises.Rmd-->

# Week 7 exercise solutions

## World happiness report solutions
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/world_happiness_solutions.png", auto_pdf = TRUE)
``` 
1. Read in the file
```{r eval=TRUE}
happy_df <- read.csv("world_happiness_report_2016.csv", 
                      check.names = FALSE,
                      stringsAsFactors = TRUE,
                      sep = ","
                      )
```

2. Answer the following questions using the output from one __function__:
```{r eval=TRUE}
summary(happy_df)
```
- How many countries are in the region "Western Europe"?
    + __21__
- What is the maximum number in the "Happiness Score" column?
    + __7.526__
- From the columns "Economy (GDP per Capital)" to "Dystopia Residual", which has the highest mean and which has the lowest?
    + __Highest: "Dystopia Residual" with 2.3258__
    + __Lowest: "Family" with 0.13762__

3.Produce the plot
```{r eval=TRUE, fig.width= 8, fig.height=8}
#Fit linear model of Economy (x) against Family (y)
fit_economy_family <- 
  lm(Family~`Economy (GDP per Capita)`, data = happy_df)
#Create string for linear equation
c <- round(fit_economy_family$coefficients[1], digits = 4)
m <- round(fit_economy_family$coefficients[2], digits = 4)
lm_equation <- paste0("y = ", m , "x + ", c)
#Produce plot
plot(x = happy_df$`Economy (GDP per Capita)`,
     y = happy_df$Family,
     main = "Comparison of the effect of \n Economy and Family on happiness",
     xlab = "Economy (GDP per Capita)",
     ylab = "Family",
     pch = as.numeric(happy_df$Region),
     xlim = c(0,2), ylim = c(0,1.5),
     col = 1)
#Add abline
abline(fit_economy_family, col = "mediumslateblue")
#Add equation to top right
text(x = 0.4, y = 1.1, labels = lm_equation)
#Add the legend
legend(x = "bottomright",
       pch = 1:nlevels(happy_df$Region),
       legend = levels(happy_df$Region))
```

4. Save plot as png file
```{r eval=FALSE}
#PNG command
png(filename = "Economy_vs_family.png", 
    units = "in", height = 8, width = 8, res = 200)
#Produce plot
plot(x = happy_df$`Economy (GDP per Capita)`,
     y = happy_df$Family,
     main = "Comparison of the effect of \n Economy and Family on happiness",
     xlab = "Economy (GDP per Capita)",
     ylab = "Family",
     pch = as.numeric(happy_df$Region),
     xlim = c(0,2), ylim = c(0,1.5),
     col = 1)
#Add abline
abline(fit_economy_family, col = "mediumslateblue")
#Add equation to top right
text(x = 0.4, y = 1.1, labels = lm_equation)
#Add the legend
legend(x = "bottomright",
       pch = 1:nlevels(happy_df$Region),
       legend = levels(happy_df$Region))
#dev.off
dev.off()
```

5. Answers for the following questions:
- Does the linear model have a positive or negative gradient?
    + __Positive__ (m = 0.4328)6
- Which variable (Economy or Family) has higher values?
    + __Economy__
- If the value of Economy was 2.1 what would be the predictive value of Family according to the linear model equation?
    + __(0.4328*2.1) + 0.3808 = 1.28968__
- Which region appears to have the highest values for Economy and for Family?
    + __Western Europe__

6. Produce boxplot
```{r eval=TRUE, fig.width= 16, fig.height=10}
#Change level names
short_region_names <- 
  c("OZ_n_NZ", "C_n_E_Europe", "E_Asia", "Latin_A_n_Carib",
    "ME_n_N_Africa", "N_America", "SE_Asia", "S_Asia",
    "Sub_Saharan", "W_Europe")
levels(happy_df$Region) <- short_region_names
#Create boxplot
boxplot(`Happiness Score`~Region, data = happy_df, 
        ylim = c(0,10),
        col = 1:nlevels(happy_df$Region),
        main = "Happiness scores across regions"
)
```

7. Save as jpeg
```{r eval=FALSE}
#jpeg
jpeg(filename = "Region_happiness_boxplots.jpg", units = "px",
     width = 1500, height = 750 )
#Create boxplot
boxplot(`Happiness Score`~Region, data = happy_df, 
        ylim = c(0,10),
        col = 1:nlevels(happy_df$Region),
        main = "Happiness scores across regions"
)
#dev.off
dev.off()
```

8. T-tests
```{r eval=TRUE}
#Subset the data frames to get vectors of our regions of interest
WE_happiness <- happy_df[happy_df$Region == "W_Europe","Happiness Score"]
NA_happiness <- happy_df[happy_df$Region == "N_America","Happiness Score"] 
SA_happiness <- happy_df[happy_df$Region == "S_Asia","Happiness Score"] 
SEA_happiness <- happy_df[happy_df$Region == "SE_Asia","Happiness Score"]
#Carry out t-tests
WE_NA_ttest <- t.test(WE_happiness, NA_happiness)
WE_SA_ttest <- t.test(WE_happiness, SA_happiness)
SA_SEA_ttest <- t.test(SA_happiness, SEA_happiness)
#Extract p values into a new vector with element names
region_happiness_pvalues <- c(WE_NA = WE_NA_ttest$p.value,
                              WE_SA = WE_SA_ttest$p.value,
                              SA_SEA = SA_SEA_ttest$p.value)
#Logical to determine if the p-value is less than 0.05
#I.e. the means are significantly different
region_happiness_pvalues < 0.05
```

<!--chapter:end:19-Week_7_exercises_solutions.Rmd-->

# Week 8 - Basic programming
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/programming.png", auto_pdf = TRUE)
``` 
This week we will be look at some basic programming with R. This will involve __loops__, __if__ statements, and creating your own __functions__.  However, before carrying out some programming we will look a R's __recycle rule__

## Recycle rule
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/recycle.png", auto_pdf = TRUE)
``` 
When two __objects__ of different lengths act upon each other the smaller __object__ will be recycled so each element in the larger __object__ is acted upon.

We will demonstrate this with the below example. Run the command below and then read the explanation.
```{r eval=FALSE}
small_vec <- 1:3
large_vec <- rep(1,9) 
small_vec * large_vec
```

- `small_vec` is a __vector__ with 3 __elements__, the numbers 1 to 3.
- `large_vec` is a __vector__ with 9 __elements__, this is the number 1 repeated 9 times.
- As `small_vec` is 3 times smaller than `large_vec` each __element__ in `small_vec` is recycled 2 times on top of the first usage.
    - The first `small_vec` __element__ is used to multiply the 1st, 4th, and 7th positions of `large_vec`.
    - The second `small_vec` __element__ is used to multiply the 2nd, 5th, and 8th positions of `large_vec`.
    - The last/third `small_vec` __element__ is used to multiply the 3rd, 6th, and 9th positions of `large_vec`.
    
Below is an example with a visualisation. `large_vec` is the numbers 1 to 9 this time:
```{r eval=FALSE}
small_vec <- 1:3
large_vec <- 1:9 
small_vec * large_vec
```

```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/recycle_rule_example_1.png", auto_pdf = TRUE)
``` 

Depending on the length of the large __vector__ the __elements__ of the smaller __vector__ may be recycled an uneven amount of times. For example:

- The smaller __vector__ has 3 __elements__.
- The larger __vector__ has 4 __elements__.
- The 1st __element__ of the smaller __vector__ would be used twice (recycled once).
- The 2nd & 3rd __elements__ of the smaller __vector__ would be used once (not recycled).

Below is a quick example of this. You should notice a warning is printed out as the length of the __objects__ are not multiples of each other. However, above the error is the correct output.
```{r eval=FALSE}
1:3 * rep(1,4)
```
 
Warnings usually mean the code will run fine but R thinks you may have done something wrong which you should check. Errors on the other hand mean the R code did not work.
 
Below are a few more examples of using the recycle rule:
```{r eval=FALSE}
#When you multiply one number (scalar) by a numeric vector
#You are recycling the one number (scalar)
2 * 1:6
#Some numeric recycling
1:2 * 1:10
1:4 + 1:8
8:1 - 1:4
2:1 / 1:4
(1:2 + 3:6) * seq(10, 120, 10)
#Strings can be recycled with the paste() function
#You'll notice that no warnings appear this time
#even though the lengths of the variables are not multiples
recyclable_materials <- c("A:aluminium","B:glass","C:paper")
recycle_centres <- rep(
  c("1:old swan","2:otterspool","3:south sefton","4:Huyton","5:Kirkby"),
  2
)
paste0(recyclable_materials, " can be recycled at ", recycle_centres)
```

## Loops
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/loop.png", auto_pdf = TRUE)
``` 

With __loops__ we can carry out the same commands and __functions__ on multiple __elements__ within a 1 dimensional __object__ (__vector__ or __list__) without having to type it out multiple times.

There are 2 main types of __loops__: __for loops__ and __while loops__.

### For loops
__For loops__ will run through a set of __variables__. Each __variable__ will be run through the set of commands once.

The basic format of a __for loop__ is (don't run the below):
```{r eval=FALSE}
for (variable in vector/list) {
  command/s
}
```

We will run a simple example below. We need the `print()` __function__ so the results are print to the console. If this was not done nothing would be print out as it is a __loop__:
```{r eval=FALSE}
for (i in 1:5) {
  print(i * 10)
}
```

In essence the below was carried out:
```{r eval=FALSE}
loop_vec <- 1:5
i <- loop_vec[1]
print(i * 10)
i <- loop_vec[2]
print(i * 10)
i <- loop_vec[3]
print(i * 10)
i <- loop_vec[4]
print(i * 10)
i <- loop_vec[5]
print(i * 10)
```

Except instead of many lines we were able to carry it out in one command rather than many.

Analogy:

- The loop is a circular assembly line.
- Machines carry out the commands on the provided __variables__.
- A worker will put the first __element__ of the provided __vector/list__ on the assembly, therefore setting it as `i`.
- The machines will carry out the commands on `i`.
- Once the worker gets the 1st set of results they will put the 2nd __element__ on the assembly line, setting it as `i`.
- This will repeat till the results from all the __elements__ are returned.

A few more examples:
```{r eval=FALSE}
for (i in c(3,6,9)) {
  print(i / 3)
  print(i / 2)
}
for (i in c(3,6,9)) {
  print(i %% 3)
  print(i %% 2)
}
#You can have loops in a loop
for (y in 1:5) {
  for (x in 1:6) {
    print(paste0(y, " + ", x, " = ", y+x))
  }
}

#Let us make the fibonacci sequence (first 10 numbers) as a vector
#First we create a vector that contains the number 1 twice
fibo_vec <- c(1,1)
#In a loop we can use the loop variable (i) to index objects
#We can use this for assignment and subsetting
for (i in 3:10) {
  fibo_vec[i] <- fibo_vec[i-1] + fibo_vec[i-2]
}
#Check out the vector
fibo_vec
```

A lot of what we have been doing we could do without __loops__. Where I find __for loops__ handy is when I want to carry out a task on multiple columns or rows.

We can use __for loops__ to quickly create a multiplication table in a matrix.
```{r eval=FALSE}
#First we create a matrix with NA values
#Make sure it contains the number of rows and columns we want
multiplication_mat <- matrix(data = NA, nrow = 10, ncol = 10)
#Next we create a vector to loop over
loop_vec <-  1:10
#Now to loop through the loop_vec for the columns
for (c in loop_vec) {
  #Next we loop through the loop_vec for the rows
  for (r in loop_vec){
    #Calculate the multiplication
    multiply_number <- c * r
    #Assign the relevant position in the matrix to the multiplication
    multiplication_mat[r,c] <- multiply_number
  }
}
#Check the matrix
multiplication_mat
```

We can then use __for loops__ to carry out specific commands to each column or each row.
```{r eval=FALSE}
#First thing we are going to do is divide each number in the matrix
#By the column total of its column
#We'll save the results in a new matrix called mult_prop_col_mat
#Create the new matrix
mult_prop_col_mat <- multiplication_mat
#Loop through the columns
for (c in 1:ncol(mult_prop_col_mat)) {
  #Calculate column total
  column_total <- sum(mult_prop_col_mat[,c])
  #Assign calculated proportion vector to the column
  mult_prop_col_mat[,c] <- mult_prop_col_mat[,c] / column_total
}
#check new matrix
mult_prop_col_mat

#We'll do the sam again but for each row
#This time with no annotation
mult_prop_row_mat <- multiplication_mat
for (r in 1:nrow(mult_prop_row_mat)) {
  mult_prop_row_mat[r,] <- 
    mult_prop_row_mat[r,] / 
    sum(mult_prop_row_mat[r,])
}
mult_prop_row_mat
```

Hopefully this is clear how __for loops__ can be used. Further down we'll work with a real dataset to show some real world applications. However, for now we will go onto __while loops__.

### While loops
I do not use __while loops__ often so we will only briefly go over them. A __while loop__ will loop over a series of commands until a condition is no longer met. Conditions will either be TRUE or FALSE (logical)

The format of a __while loop__:
```{r eval=FALSE}
while (condition) {
  command/s
}
```

Below is an example:
```{r eval=FALSE}
i <- 1
while (i < 10) {
  print(paste0(
    "At the start of loop number:", i, ", the variable i is ", i))
  i <- i + 1
  print(paste0("-----"))
}
i
```

In this case 1 is being added to `i` in each loop. The loop keeps going till `i` is no longer less than 10. Therefore, at the end of the __while loop__ `i` is equal to 10.

One final point on __while loops__. You can make a __while loop__ so the condition will always be met. If this is the case the __while loop__ will never finish and you'll need to use "ESC" in the console to stop the __while loop__. An example is below which you should not run:
```{r eval=FALSE}
i <- 1
while (i > 0) {
  print(paste0(
    "At the start of loop number:", i, ", the variable i is ", i))
  i <- i + 1
  print(paste0("-----"))
}
i
```

## If statements
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/flow_chart.png", auto_pdf = TRUE)
``` 
__If statments__ allow for different commands to be carried out depending on __if__ a condition is met. 

This can be thought of like a flow chart where you go one way if you answer yes and another if you answer no. Example:

- Are you thirsty?
- If yes, have something to drink.
- If no, do not have something to drink.

Basic format of an __if equation__:
```{r eval=FALSE}
if (condition) {
  command/s if condition true
} else {
  command/s if condition false
}
```

I'll show you a coding example using the modulus (`%%`) __operator__.
```{r eval=FALSE}
#Create a scalar
i <- 3
#If statement determing if the remainder of i/2 is 1
if (( i %% 2) == 1) {
  paste0(i, " is odd")
} else {
  paste0(i, " is even")
}
```

You can have an __if statement__ within a __loop__.

__Reminder__: We need to use `print()` within __loops__ to print results to the console.
```{r eval=FALSE}
for (i in 0:9) {
  #If statement determining if the remainder of i/2 is 1
  if (( i %% 2) == 1) {
    print(paste0(i, " is odd"))
  } else {
    print(paste0(i, " is even"))
  }
}
```

##Custom Functions
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/custon_function.png", auto_pdf = TRUE)
``` 
Through out this course we have used many __functions__. However, you may want a __function__ that does not exist. In this case you can create your own.

The format to create your own __function__ is:
```{r eval=FALSE}
function_name <- function(inputs_and_option_names){
  command/s
  return(new_variable)
}
```

There are 2 new __functions__ above:

- `function()`: This __function__ creates the new __function__.
- `return()`: This specifies what will be returned when we run our new __function__.

A quick example to add VAT to each number in a __vector__:
```{r eval=FALSE}
#Create the function
add_vat <- function(input_num_vec) {
  vat_vec <- input_num_vec * 1.2
  return(round(vat_vec, digits = 2))
}
#Example running the new function
add_vat(0.99)
add_vat(c(9.99, 8.78, 2.45))
```

In the below example we will create a __function__ that will __return__ all numbers that are multiples of 5 from the input __vector__.
```{r eval=FALSE}
#Create the function
all_mult_5_func <- function(input_num_vec){
  #Create an empty vector prior to loop to contain multiples of 5
  out_vec <- vector(mode="numeric", length=0)
  #Loop to add multiples of 5 to out_vec
  for (i in input_num_vec){
    #If statement so only multiples of 5 are added to the out_vec
    #In this case no else part is required
    if ((i %% 5) == 0 ){
      out_vec <- c(out_vec, i)
    }
  }
  #Have the return function at the very end
  return(out_vec)
}
#Try out the function with some vectors
all_mult_5_func(1:20)
all_mult_5_func(seq(from = 0, to = 100, by = 8))
all_mult_5_func(1:10 * 5)
```

Like with normal __functions__ a custom one can be given multiple arguments if built that way. Knowing this we will alter the above __function__ so it can __return__ all numbers that are multiples of a chosen number.
```{r eval=FALSE}
#When creating the function add in another input/option name
all_mult_x_func <- function(input_num_vec, multiple){
  #Create an empty vector prior to loop to contain the multiples
  out_vec <- vector(mode="numeric", length=0)
  #Loop to add the multiples to out_vec
  for (i in input_num_vec){
    #If statement so only multiples of the chosen number are added to the out_vec
    #In this case no else part is required
    if ((i %% multiple) == 0 ){
      out_vec <- c(out_vec, i)
    }
  }
  #Have the return function at the very end
  return(out_vec)
}
#Try out the function with some vectors
all_mult_x_func(input_num_vec = 1:20, multiple = 2)
all_mult_x_func(seq(from = 0, to = 100, by = 8), 4)
all_mult_x_func(1:10 * 5, 10)
#As always we can assign the output of a function to a new variable
multiples_of_6_btwn_1_100 <- all_mult_x_func(1:100, 6)
```

With all that we are now going to a real dataset in the next session to show the use and applications of these new techniques.

<!--chapter:end:20-Basic_programming.Rmd-->

# Student grades example
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/grades.png", auto_pdf = TRUE)
``` 
In this section we are going to go through analysing datasets of students grades. 

## The student grades data
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/data.png", auto_pdf = TRUE)
``` 
Look in the directory "Week_8_files" and you'll see five files called "student_grades_group_X.tsv" where X is the letters A-E.

These files contain the marks secured by USA students in various subjects. The files are separated by anonymised race/ethnicity (groups A-E). 

The files each contain the columns:

- __gender__: female or male.
- __parental level of education__: some high school, high school, associate's degree, some college, bachelor's degree, or master's degree.
- __lunch__: Whether the student ate free/reduced lunches or standard lunches.
- __test prepartion course__: Whether the student completed a test prep course (completed) or not (none).
- __math score__: The student's math score.
- __reading score__: The student's reading score.
- __writing score__: The student's writing score.

Source of data: https://www.kaggle.com/spscientist/students-performance-in-exams

## Analysis script
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/hashtag2.png", auto_pdf = TRUE)
``` 
Before carrying on I would suggest to set your working directory into the directory "Week_8_files".

Now create a new R Script and save it as "student_grades.R" in the "Week_8_files" directory. It is useful to have your scripts close to their relevant data.

Ensure you use annotations and code sections to keep your script organised and tidy.

One extra tip: I normally like to keep a `setwd()` command at the top of my R Scripts so the script will set itself to the correct working directory. I just copy the relevant command from the __console__.

## Reading in and preprocessing the data
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/r_read.png", auto_pdf = TRUE)
``` 
We are going to first read in the data and carry out some changes to it. First we'll carry this out on just the group A data.

Read in the group A TSV (tab separated value) file:
```{r eval=FALSE}
group_a_df <- read.csv("student_grades_group_A.tsv",
                       sep = "\t",
                       stringsAsFactors = TRUE,
                       check.names = FALSE)
```

When you first read in a file it is always good practice to check the resulting __data frame's__ contents:
```{r eval=FALSE}
#Check the top 5 rows
head(group_a_df)
#View the data frame
View(group_a_df)
#Summary of each of its columns
summary(group_a_df)
```

There are three main things we want to do with this __data frame__:

- Change the column names so spaces are underscores. We can carry this out with `gsub()` (Week 4).
- Change the order of the levels for the column "parental level of education" so they are in order from least to most education. We can do this with the `factor()` __function__ (week 6).
- Add a group column which will contain the information on what race/ethnicity group each student belongs to. This will contain all the same info for this __data frame__ but it will be useful later on. We are happy for it to be a __character__ column for now.

Let us carry out these tasks:
```{r eval=FALSE}
#Change spaces to _ in column names
colnames(group_a_df) <- gsub(pattern = " ", 
                             replacement = "_",
                             x = colnames(group_a_df))
#check our change
colnames(group_a_df)

#Change the order of the parental level of education levels
edu_level_order <- c("some high school","high school",
                     "associate's degree","some college",
                     "bachelor's degree","master's degree")         
group_a_df$parental_level_of_education <- factor(
  group_a_df$parental_level_of_education,
  levels = edu_level_order
)
#check our change
levels(group_a_df$parental_level_of_education)

#Add group column using the recycle rule
group_a_df[,"group"] <- "group_A"
#check the new column
group_a_df$group
```

Great we have created code to __read__ in our file and preprocess the __data frame__. We have checked the output and know it produces the __data frame__ in the format we want.

We could copy and paste the code four times and change the relevant __variable names__ to __read__ in groups B-E. This would be pretty annoying and time consuming though.

Instead let us create a __function__ to do this for us. This will mostly use the same code above with __variable names__ changed. There are a few changes though especially for the "group_name"" column creation.

__Note__: The __variable names__ used within the __function__ should not be the same as any you are using outside the __function__.
```{r eval=FALSE}
#Function name: "read_and_preprocess"
#Input: file_name
read_and_preprocess <- function(file_name){
  #read in the file
  df <- read.csv(file_name, sep = "\t",
                 stringsAsFactors = TRUE, check.names = FALSE)
  #column name change
  colnames(df) <- gsub(pattern = " ", replacement = "_", x = colnames(df))
  #Parental level of education order
  edu_level_order <- c("some high school","high school",
                       "associate's degree","some college",
                       "bachelor's degree","master's degree")         
  df$parental_level_of_education <- 
    factor(df$parental_level_of_education, levels = edu_level_order)
  #extract the group name from the file name
  group_name <- gsub(".*_group","group", file_name)
  group_name <- gsub(".tsv","", group_name)
  #Add group column
  df$group <- group_name
  #Return df
  return(df)
}
```

We have created the ___function__. Now to run it with all our files:
```{r eval=FALSE}
#We can specify the option name
#This is useful when we have lots of options
group_a_df <- read_and_preprocess(file_name = "student_grades_group_A.tsv")
#But we don't need to, which is useful with less options
group_b_df <- read_and_preprocess("student_grades_group_B.tsv")
group_c_df <- read_and_preprocess("student_grades_group_C.tsv")
group_d_df <- read_and_preprocess("student_grades_group_D.tsv")
group_e_df <- read_and_preprocess("student_grades_group_E.tsv")
```

## Combining the data frames
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/combine.png", auto_pdf = TRUE)
``` 
A lot of the time we have multiple files but we want all the data to be in one __data frame__.

The first step is to create a __list__ containing our __data frames__. A __list__ is just like a __vector__ except it can hold heterogeneous data (multiple classes) whilst a __vector__ can only contain homogeneous data (one class).

We will use this so we can __loop__ over our __data frames__. There is more to __lists__, if you would like to see more check out: https://rc2e.com/datastructures#intro-DataStructures

We'll start with creating our __list__ then using a __for loop__ to print out the first 3 rows of each __data frame__. To create a __list__ of __data frames__ we use the __function__ `list()` just like we would with `c()`.
```{r eval=FALSE}
#Create list
df_lst <- list(group_a_df, group_b_df, group_c_df, group_d_df, group_e_df)
#Loop through list
#It is best to loop through 1 to the number of data frames
for (df in df_lst) {
  #Print the first element of the group name column
  print(df$group[1])
  #Print the first 3 rows
  print(head(x = df, n = 3))
}
```

With our __list__ we can combine the __data frames__ into one __data frame__ with a __for loop__ and `rbind()`.

It would be very simple but `rbind()` will not function if one of the __data frames__ provided does not exist. We will therefore use an __if statement__ to create a __data frame__ for our combined data in the first loop.

We will use a new function, `exists()`. It will return `TRUE` if the provided __variable__ exists and `FALSE` if it does not. The provided __variable name__ needs to be a character (a string in quotes in this case).
```{r eval=FALSE}
#First ensure the variable we want to create does not exist
rm(student_grades_df)
#Now to loop through our list
for (df in df_lst) {
  #If statment using the exists() function
  #If the variable student_grades_df exists
  if (exists("student_grades_df")) {
    #Combine student_grades_df with df by rows
    student_grades_df <- rbind(student_grades_df, df)
  } else {
    #else if it doesn't exist assign df as student_grades_df
    student_grades_df <- df
  }
}

#whilst we are here let us change the group column to a factor now
#No need to change the order as we are happy with it being alphabetical
student_grades_df$group <- factor(student_grades_df$group)
```

## Saving the data frame
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/r_save.png", auto_pdf = TRUE)
``` 

You can write the new __data frame__ to a text file. This is good if you want to use the file outside of R. 

What if you want to save a R __object__ so you can use it later without having to run all the script you used to create it or __reading__ in a file you created?

You can use the `save()` function:
```{r eval=FALSE}
save(student_grades_df, file = "student_grades_df")
```

The above created a file called "students_grades_df" that is not human-readable. It contains the __data frame__ `student_grades_df`. The name of the file and __variable__ do not have to match but I find it easier if they do.

You can then load in the file which will load the __variable__ with its __variable name__. Before we load the data we will remove our current `student_grades_df` __object__:
```{r eval=FALSE}
#Remove the data frame
rm(student_grades_df)
#Load in the data frame
load("student_grades_df")
```

Saving your R __objects__ acts as very good checkpoints after code that takes a long time to run.

## Scaling & Grading
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/letter_grades.png", auto_pdf = TRUE)
``` 
We currently have the base scores (%) for the students but not their letter grade (A,B,C, or F in this case).

Before we provide the grades we are go to scale each student's results. There are complicated ways to do this but we will get the mean score for each topic (math, writing, and reading). For each score below the mean we will minus 5 and for each score above will will add 5. Scores equal to the mean will not be affected.
```{r eval=FALSE}
#Create function to scale score vector
scale_score <- function(score_vec){
  #Get mean score which we will round to 0 decimal places
  mean_score <- round(mean(score_vec), digits = 0)
  #Create an empty scale_score_vec to add to
  scale_score_vec <- c()
  #Loop through scores to scale them
  for (i in 1:length(score_vec)) {
    score <- score_vec[i]
    #if to add 5 if larger than mean
    if (score > mean_score) { score <- score + 5 }
    #if to minus 5 if lower than mean
    if (score < mean_score) { score <- score - 5 }
    #We don't add or minus anything if the score is equal to the mean
    #Add the scaled score to the scale_score_vec
    scale_score_vec <- c(scale_score_vec, score)
  }
  #Return the created vector
  return(scale_score_vec)
}

#Run the function on the topics to create new scaled score topics
student_grades_df$math_scaled_score <- 
  scale_score(student_grades_df$math_score)
student_grades_df$reading_scaled_score <- 
  scale_score(student_grades_df$reading_score)
student_grades_df$writing_scaled_score <- 
  scale_score(student_grades_df$writing_score)
```

Now we have scaled the scores. Some students now have more than 100% and some have less than 0% but that is fine. It doesn't matter for their final grade.

We will give out grades based on the scaled scores like so:

- __A__: >=95%
- __B__: >=80% and <95%
- __C__: >=60% and <80%
- __F__: <60%

We can carry this out with the below code. To create it I copied the last code block and altered it. This time we use `else if` so the subsequent __ifs__ only work if all the previous __ifs__ were `FALSE`.
```{r eval=FALSE}
#Create function to grade a vector
grade_score <- function(score_vec){
  #Create empty grade_vec to add to
  grade_vec <- c()
  #Loop through scores to scale them
  for (i in 1:length(score_vec)) {
    #get current score
    score <- score_vec[i]
    #if statements with else ifs
    if (score >= 95) {
      grade_vec[i] <- "A"
    } else if (score >= 80) {
      grade_vec[i] <- "B"
    } else if (score >= 60) {
      grade_vec[i] <- "C"
    } else {
      grade_vec[i] <- "F"
    }
  }
  #Return the created vector as a factor
  return(factor(grade_vec))
}
#Run the function on the topics to create the grade columns
student_grades_df$math_grade <- 
  grade_score(student_grades_df$math_scaled_score)
student_grades_df$reading_grade <- 
  grade_score(student_grades_df$reading_scaled_score)
student_grades_df$writing_grade <- 
  grade_score(student_grades_df$writing_scaled_score)
```

That is he last edit we will do to our __data frame__ so lets __save__ it.
```{r eval=FALSE}
save(student_grades_df, file = "student_grades_df")
```

## Some quick plots
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/bar_chart.png", auto_pdf = TRUE)
``` 
Below are some quick plots with their code.
```{r echo=FALSE, eval=TRUE}
load("student_grades_df")
```

First let us see the distribution of grades for the three topics:
```{r echo=TRUE, eval=TRUE}
#Math
#With plot()
plot(table(student_grades_df$math_grade))
```
```{r echo=TRUE, eval=TRUE}
#With barplot()
barplot(table(student_grades_df$math_grade))
```
```{r echo=TRUE, eval=TRUE}
#Reading
#With barplot()
barplot(table(student_grades_df$reading_grade))
```
```{r echo=TRUE, eval=TRUE}
#Writing
#With barplot()
barplot(table(student_grades_df$writing_grade))
```

It seems the grades are pretty low. Maybe that is to do with our scaling and harsh grading.

Quickly we'll check the histogram of all the scores and all the scaled scores.
```{r echo=TRUE, eval=TRUE}
#scores
hist(
  c(student_grades_df$math_score, 
    student_grades_df$reading_score,
    student_grades_df$writing_score
  )
)
```
```{r echo=TRUE, eval=TRUE}
#scaled scores
hist(
  c(student_grades_df$math_scaled_score, 
    student_grades_df$reading_scaled_score,
      student_grades_df$writing_scaled_score
  )
)
```

We can see a big dip in the middle of the scaled scores but not in the non-scaled scores. Seems scaling just increased the distance between people who did better than others.

Last thing is we'll create a boxplot of math scores separating the x axis by some metadata.
```{r echo=TRUE, eval=TRUE, fig.width = 10}
boxplot(
  math_score~test_preparation_course+lunch,
  data = student_grades_df)
```

I think that is plenty of coding for today and for this course. Thank you very much!

## Tips for creating your own loops and functions
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/tip_box.png", auto_pdf = TRUE)
``` 
Before you go here are some quick tips.

- Create the code outside the __loop/function__ to begin with.
- Test with a small __object__ to start (e.g. a part of a __data frame__).
- Keep backups of code.
- If you encounter errors try running your code step by step to determine where the error is.
- It can useful to run the code inside your __loop/function__ by setting the __loop/function variable__ (e.g. `i <- 1`)

<!--chapter:end:21-Student_grades_example.Rmd-->

# Further resources
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/internet.png", auto_pdf = TRUE)
``` 

## R user groups and forums

- https://jumpingrivers.github.io/meetingsR/r-user-groups.html#europe
- https://www.r-consortium.org/blog/2019/09/09/r-community-explorer-r-user-groups
- https://r-dir.com/community/forums.html

## Base R books and links

__Quick-R__: https://www.statmethods.net/index.html

__R Cookbook__: https://rc2e.com/

## R cheat sheets

https://rstudio.com/resources/cheatsheets/

## Advanced R topics

__R packages__: https://r-pkgs.org/

__R for Data Science__: https://r4ds.had.co.nz/

__R Graphics Cookbook__: https://r-graphics.org/

__Fundamentals of Data Visualization__: https://clauswilke.com/dataviz/

__R BOOKDOWN__ (used ot make this book): https://bookdown.org/

__Hands-On Programming with R__: https://rstudio-education.github.io/hopr/

__Efficient R programming__: https://csgillespie.github.io/efficientR/

## Datasets
I got a lot of my datasets from Kaggle:
https://www.kaggle.com/

<!--chapter:end:22-Further_resources.Rmd-->


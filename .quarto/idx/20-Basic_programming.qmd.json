{"title":"Basic programming","markdown":{"headingText":"Basic programming","containsRefs":false,"markdown":"```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/programming.png\", auto_pdf = TRUE)\n``` \nIn this chapter we will be look at some basic programming with R. This will involve __loops__, __if__ statements, and creating your own __functions__.\n\nCreate and use the directory \"Chapter_20-21\" as the working directory for this chapter. Additionally create a new script called \"Programming.R\" for this chapter.\n\n## Recycle rule\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/recycle.png\", auto_pdf = TRUE)\n``` \nWhen two __objects__ of different lengths act upon each other the smaller __object__ will be recycled so each element in the larger __object__ is acted upon.\n\nWe will demonstrate this with the below example. Run the command below and then read the explanation.\n```{r eval=FALSE}\nsmall_vec <- 1:3\nlarge_vec <- rep(1,9) \nsmall_vec * large_vec\n```\n\n- `small_vec` is a __vector__ with 3 __elements__, the numbers 1 to 3.\n- `large_vec` is a __vector__ with 9 __elements__, this is the number 1 repeated 9 times.\n- As `small_vec` is 3 times smaller than `large_vec` each __element__ in `small_vec` is recycled 2 times on top of the first usage.\n    - The first `small_vec` __element__ is used to multiply the 1st, 4th, and 7th positions of `large_vec`.\n    - The second `small_vec` __element__ is used to multiply the 2nd, 5th, and 8th positions of `large_vec`.\n    - The last/third `small_vec` __element__ is used to multiply the 3rd, 6th, and 9th positions of `large_vec`.\n    \nBelow is an example with a visualisation. `large_vec` is the numbers 1 to 9 this time:\n```{r eval=FALSE}\nsmall_vec <- 1:3\nlarge_vec <- 1:9 \nsmall_vec * large_vec\n```\n\n```{r, fig.align = 'center',out.width= '80%', echo=FALSE }\nknitr::include_graphics(path = \"figures/recycle_rule_example_1.png\", auto_pdf = TRUE)\n``` \n\nDepending on the length of the large __vector__ the __elements__ of the smaller __vector__ may be recycled an uneven amount of times. For example:\n\n- The smaller __vector__ has 3 __elements__.\n- The larger __vector__ has 4 __elements__.\n- The 1st __element__ of the smaller __vector__ would be used twice (recycled once).\n- The 2nd & 3rd __elements__ of the smaller __vector__ would be used once (not recycled).\n\nBelow is a quick example of this. You should notice a warning is printed out as the length of the __objects__ are not multiples of each other. However, above the warning is the correct output.\n```{r eval=FALSE}\n1:3 * rep(1,4)\n```\n \nWarnings usually mean the code will run fine but R thinks you may have done something wrong which you should check. Errors on the other hand mean the R code did not work.\n \nBelow are a few more examples of using the recycle rule:\n```{r eval=FALSE}\n#When you multiply one number (scalar) by a numeric vector\n#You are recycling the one number (scalar)\n2 * 1:6\n#Some numeric recycling\n1:2 * 1:10\n1:4 + 1:8\n8:1 - 1:4\n2:1 / 1:4\n(1:2 + 3:6) * seq(10, 120, 10)\n#Strings can be recycled with the paste() function\n#You'll notice that no warnings appear this time\n#even though the lengths of the variables are not multiples\nrecyclable_materials <- c(\"A:aluminium\",\"B:glass\",\"C:paper\")\nrecycle_centres <- rep(\n  c(\"1:old swan\",\"2:otterspool\",\"3:south sefton\",\"4:Huyton\",\"5:Kirkby\"),\n  2\n)\npaste0(recyclable_materials, \" can be recycled at \", recycle_centres)\n```\n\n## Loops\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/loop.png\", auto_pdf = TRUE)\n``` \n\nWith __loops__ we can carry out the same commands and __functions__ on multiple __elements__ within a 1 dimensional __object__ (__vector__ or __list__) without having to type it out multiple times.\n\nThere are 2 main types of __loops__: __for loops__ and __while loops__.\n\n### For loops\n__For loops__ will run through a set of __variables__. Each __variable__ will be run through the set of commands once.\n\nThe basic format of a __for loop__ is (don't run the below):\n```{r eval=FALSE}\nfor (variable in vector/list) {\n  command/s\n}\n```\n\nWe will run a simple example below. We need the `print()` __function__ so the results are print to the console. If this was not done nothing would be print out as it is a __loop__:\n```{r eval=FALSE}\nfor (i in 1:5) {\n  print(i * 10)\n}\n```\n\nIn essence the below was carried out:\n```{r eval=FALSE}\nloop_vec <- 1:5\ni <- loop_vec[1]\nprint(i * 10)\ni <- loop_vec[2]\nprint(i * 10)\ni <- loop_vec[3]\nprint(i * 10)\ni <- loop_vec[4]\nprint(i * 10)\ni <- loop_vec[5]\nprint(i * 10)\n```\n\nExcept instead of many lines we were able to carry it out in one command rather than many.\n\nAnalogy:\n\n- The loop is a circular assembly line.\n- Machines carry out the commands on the provided __variables__.\n- A worker will put the first __element__ of the provided __vector/list__ on the assembly, therefore setting it as `i`.\n- The machines will carry out the commands on `i`.\n- Once the worker gets the 1st set of results they will put the 2nd __element__ on the assembly line, setting it as `i`.\n- This will repeat till the results from all the __elements__ are returned.\n\nA few more examples:\n```{r eval=FALSE}\nfor (i in c(3,6,9)) {\n  print(i / 3)\n  print(i / 2)\n}\nfor (i in c(3,6,9)) {\n  print(i %% 3)\n  print(i %% 2)\n}\n#You can have loops in a loop\nfor (y in 1:5) {\n  for (x in 1:6) {\n    print(paste0(y, \" + \", x, \" = \", y+x))\n  }\n}\n\n#Let us make the fibonacci sequence (first 10 numbers) as a vector\n#First we create a vector that contains the number 1 twice\nfibo_vec <- c(1,1)\n#In a loop we can use the loop variable (i) to index objects\n#We can use this for assignment and subsetting\nfor (i in 3:10) {\n  fibo_vec[i] <- fibo_vec[i-1] + fibo_vec[i-2]\n}\n#Check out the vector\nfibo_vec\n```\n\nA lot of what we have been doing we could do without __loops__. Where I find __for loops__ handy is when I want to carry out a task on multiple columns or rows.\n\nWe can use __for loops__ to quickly create a multiplication table in a matrix.\n```{r eval=FALSE}\n#First we create a matrix with NA values\n#Make sure it contains the number of rows and columns we want\nmultiplication_mat <- matrix(data = NA, nrow = 10, ncol = 10)\n#Next we create a vector to loop over\nloop_vec <-  1:10\n#Now to loop through the loop_vec for the columns\nfor (c in loop_vec) {\n  #Next we loop through the loop_vec for the rows\n  for (r in loop_vec){\n    #Calculate the multiplication\n    multiply_number <- c * r\n    #Assign the relevant position in the matrix to the multiplication\n    multiplication_mat[r,c] <- multiply_number\n  }\n}\n#Check the matrix\nmultiplication_mat\n```\n\nWe can then use __for loops__ to carry out specific commands to each column or each row.\n```{r eval=FALSE}\n#First thing we are going to do is divide each number in the matrix\n#By the column total of its column\n#We'll save the results in a new matrix called mult_prop_col_mat\n#Create the new matrix\nmult_prop_col_mat <- multiplication_mat\n#Loop through the columns\nfor (c in 1:ncol(mult_prop_col_mat)) {\n  #Calculate column total\n  column_total <- sum(mult_prop_col_mat[,c])\n  #Assign calculated proportion vector to the column\n  mult_prop_col_mat[,c] <- mult_prop_col_mat[,c] / column_total\n}\n#check new matrix\nmult_prop_col_mat\n\n#We'll do the same again but for each row\n#This time with no annotation\nmult_prop_row_mat <- multiplication_mat\nfor (r in 1:nrow(mult_prop_row_mat)) {\n  mult_prop_row_mat[r,] <- \n    mult_prop_row_mat[r,] / \n    sum(mult_prop_row_mat[r,])\n}\nmult_prop_row_mat\n```\n\nHopefully this is clear how __for loops__ can be used. Further down we'll work with a real dataset to show some real world applications. However, for now we will go onto __while loops__.\n\n### While loops\nI do not use __while loops__ often so we will only briefly go over them. A __while loop__ will loop over a series of commands until a condition is no longer met. Conditions will either be TRUE or FALSE (logical)\n\nThe format of a __while loop__:\n```{r eval=FALSE}\nwhile (condition) {\n  command/s\n}\n```\n\nBelow is an example:\n```{r eval=FALSE}\ni <- 1\nwhile (i < 10) {\n  print(paste0(\n    \"At the start of loop number:\", i, \", the variable i is \", i))\n  i <- i + 1\n  print(paste0(\"-----\"))\n}\ni\n```\n\nIn this case 1 is being added to `i` in each loop. The loop keeps going till `i` is no longer less than 10. Therefore, at the end of the __while loop__ `i` is equal to 10.\n\nOne final point on __while loops__. You can make a __while loop__ so the condition will always be met. If this is the case the __while loop__ will never finish and you'll need to use \"ESC\" in the console to stop the __while loop__. An example is below which you should not run:\n```{r eval=FALSE}\ni <- 1\nwhile (i > 0) {\n  print(paste0(\n    \"At the start of loop number:\", i, \", the variable i is \", i))\n  i <- i + 1\n  print(paste0(\"-----\"))\n}\ni\n```\n\n## If statements\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/flow_chart.png\", auto_pdf = TRUE)\n``` \n__If statements__ allow for different commands to be carried out depending on __if__ a condition is met. \n\nThis can be thought of like a flow chart where you go one way if you answer yes and another if you answer no. Example:\n\n- Are you thirsty?\n- If yes, have something to drink.\n- If no, do not have something to drink.\n\nBasic format of an __if equation__:\n```{r eval=FALSE}\nif (condition) {\n  command/s if condition true\n} else {\n  command/s if condition false\n}\n```\n\nI'll show you a coding example using the modulus (`%%`) __operator__.\n```{r eval=FALSE}\n#Create a scalar\ni <- 3\n#If statement determing if the remainder of i/2 is 1\nif (( i %% 2) == 1) {\n  paste0(i, \" is odd\")\n} else {\n  paste0(i, \" is even\")\n}\n```\n\nYou can have an __if statement__ within a __loop__.\n\n__Reminder__: We need to use `print()` within __loops__ to print results to the console.\n```{r eval=FALSE}\nfor (i in 0:9) {\n  #If statement determining if the remainder of i/2 is 1\n  if (( i %% 2) == 1) {\n    print(paste0(i, \" is odd\"))\n  } else {\n    print(paste0(i, \" is even\"))\n  }\n}\n```\n\n##  Functions\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/custon_function.png\", auto_pdf = TRUE)\n``` \nThroughout this course we have used many __functions__. However, you may want a __function__ that does not exist. In this case you can create your own.\n\nThe format to create your own __function__ is:\n```{r eval=FALSE}\nfunction_name <- function(inputs_and_option_names){\n  command/s\n  return(new_variable)\n}\n```\n\nThere are 2 new __functions__ above:\n\n- `function()`: This __function__ creates the new __function__.\n- `return()`: This specifies what will be returned when we run our new __function__.\n\nA quick example to add VAT to each number in a __vector__:\n```{r eval=FALSE}\n#Create the function\nadd_vat <- function(input_num_vec) {\n  vat_vec <- input_num_vec * 1.2\n  return(round(vat_vec, digits = 2))\n}\n#Example running the new function\nadd_vat(0.99)\nadd_vat(c(9.99, 8.78, 2.45))\n```\n\nIn the below example we will create a __function__ that will __return__ all numbers that are multiples of 5 from the input __vector__.\n```{r eval=FALSE}\n#Create the function\nall_mult_5_func <- function(input_num_vec){\n  #Create an empty vector prior to loop to contain multiples of 5\n  out_vec <- vector(mode=\"numeric\", length=0)\n  #Loop to add multiples of 5 to out_vec\n  for (i in input_num_vec){\n    #If statement so only multiples of 5 are added to the out_vec\n    #In this case no else part is required\n    if ((i %% 5) == 0 ){\n      out_vec <- c(out_vec, i)\n    }\n  }\n  #Have the return function at the very end\n  return(out_vec)\n}\n#Try out the function with some vectors\nall_mult_5_func(1:20)\nall_mult_5_func(seq(from = 0, to = 100, by = 8))\nall_mult_5_func(1:10 * 5)\n```\n\nLike with normal __functions__ a custom one can be given multiple arguments if built that way. Knowing this we will alter the above __function__ so it can __return__ all numbers that are multiples of a chosen number.\n```{r eval=FALSE}\n#When creating the function add in another input/option name\nall_mult_x_func <- function(input_num_vec, multiple){\n  #Create an empty vector prior to loop to contain the multiples\n  out_vec <- vector(mode=\"numeric\", length=0)\n  #Loop to add the multiples to out_vec\n  for (i in input_num_vec){\n    #If statement so only multiples of the chosen number are added to the out_vec\n    #In this case no else part is required\n    if ((i %% multiple) == 0 ){\n      out_vec <- c(out_vec, i)\n    }\n  }\n  #Have the return function at the very end\n  return(out_vec)\n}\n#Try out the function with some vectors\nall_mult_x_func(input_num_vec = 1:20, multiple = 2)\nall_mult_x_func(seq(from = 0, to = 100, by = 8), 4)\nall_mult_x_func(1:10 * 5, 10)\n#As always we can assign the output of a function to a new variable\nmultiples_of_6_btwn_1_100 <- all_mult_x_func(1:100, 6)\n```\n\nWith all that we are now going to a real dataset in the next session to show the use and applications of these new techniques.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"20-Basic_programming.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.35","editor":"source","theme":"cosmo","max-width":"3000px","toc-location":"left","toc-title":"In this chapter","margin":0,"page-layout":"full"},"extensions":{"book":{"multiFile":true}}}}}
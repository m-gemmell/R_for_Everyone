{"title":"Files and subsetting data","markdown":{"headingText":"Files and subsetting data","containsRefs":false,"markdown":"\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/R_df.png\")\n```\n\n## Reading from a file\n\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/r_read.png\")\n```\n\nIn chapter 4 we created **data frames** with R **functions**. This was useful to help understand how **data frames** work in R. However, in real life you will most likely not do this very often. Instead you will have data files you need to analyse with R.\n\nYou can get your data into R by having R **read** your file.\n\nPrior to using a file you will need to acquire it. Make a directory/folder called \"Chapter_7\" within your main directory/folder for this workshop. Download the following file into your \"Chapter_7\" directory:\n\n```{r echo=FALSE}\nlibrary(downloadthis)\ndownload_link(\n  link=\"https://m-gemmell.github.io/R_for_everyone/downloads/Liverpool_beaches.csv\",\n  button_label = \"Download Liverpool_beaches.csv\",\n  button_type = \"danger\",\n  has_icon = TRUE,\n  icon = \"fa fa-save\",\n  self_contained = TRUE\n)\n```\n\n<br> Next set your working directory to this new directory ([Directories](#directories)). You will stay here for this chapter.\n\nThe next task to carry out is to **read** in the file \"Liverpool_beaches.csv\" . Before **reading** in the file we can check the contents of the file. This can be carried out by opening it with notepad (or similar text tool) or viewing the file with RStudio.\n\nTo view the file with RStudio:\n\n-   Use the **Files pane** of the **MISC window** to navigate to the directory containing the file.\n-   Click on the file name and then click \"View File\"\n-   This will open a tab in the **Source window** matching the file name\n\nYou will notice that the values are separated by commas as this is a \"comma separated value\" (.csv) file. Additionally, this is the same data as the \"beach_df_2\" **data frame** you created in the chapter 5 exercises.\n\n**Note**: Create a new R script file called **\"3-Files_and_subsetting.r\"** for this chapter's scripts.\n\nThere are various **functions** to **read** in files into R. My favourite that I find most consistent is `read.csv()`. Use this function to **read** in the file \"Liverpool_beaches.csv\":\n\n```{r eval=FALSE}\nliv_beaches_df <- read.csv(\"Liverpool_beaches.csv\")\n```\n\nHave a look at the newly created **data frame**. Is it how you would like it?\n\nThe row names are empty and the beach names are in the first column. Let us fix this and make it so the beach names are the row names. This can be carried out by including the option `row.names = 1` to specify the 1st column will be the row names:\n\n```{r eval=FALSE}\nliv_beaches_df <- read.csv(\"Liverpool_beaches.csv\", row.names = 1)\n```\n\nWe now know how to **read** in a csv file with `read.csv`. Therefore we will next **read** in a tab separated file containing the sales figures of fictional clothing stores through the seasons.\n\nDownload the file \"Clothing_stores.tsv\" into your \"Chapter_7\" directory and look at the file contents before **reading** them in.\n\n```{r echo=FALSE}\nlibrary(downloadthis)\ndownload_link(\n  link=\"https://m-gemmell.github.io/R_for_everyone/downloads/Clothing_stores.tsv\",\n  button_label = \"Download Clothing_stores.tsv\",\n  button_type = \"danger\",\n  has_icon = TRUE,\n  icon = \"fa fa-save\",\n  self_contained = TRUE\n)\n```\n\n<br>\n\nNow use `read.csv()` to **read** in the file. We'll set `row.names = 1` again but we will also include the option `sep = \"\\t\"`. This option specifies the columns are separated (sep) by tabs (`\"\\t\"`).\n\n```{r eval=FALSE}\nclothing_df <- read.csv(\"Clothing_stores.tsv\", row.names = 1, sep = \"\\t\")\n```\n\nLook at the resulting **data frame** and you will notice the column names have been changed by R. This is annoying but thankfully there is an easy fix. **Read** in the data again with the inclusion of the parameter `check.names = FALSE`. This will stop the function `read.csv()` from 'checking' and 'fixing' the column names. I always use this option.\n\n```{r eval=FALSE}\nclothing_df <- read.csv(\"Clothing_stores.tsv\", row.names = 1, \n                        sep = \"\\t\", check.names = FALSE)\n```\n\nYou may want to open excel files with R. Normally to do this I open the file in excel and save it as a .csv or a tab separated file and **read** this into R. Alternatively there are R packages that can directly **read** in excel files. If this is something you would like to do you can look at the following package:\n\n<https://readxl.tidyverse.org/>\n\nAn important note is that **reading** in a file into R will not change the file. You are creating a new R **object**. Modifying this **object** will not alter the original file. Later in the materials we will look into how to create new files or overwrite files by **writing**.\n\n## Subsetting data\n\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/R_subset.png\")\n```\n\nR allows you to specify specific points in **R objects**. This is one of the primary reasons R is so useful and flexible. With good use of **assignment operators** this allows for the subsetting of **variables**.\n\n### Vectors\n\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/R_square_bracket.png\")\n```\n\nWe will start with **vectors**. Before carrying out and subsetting let us create some new **vectors**. We will use a new **function** to create these, `seq()`.\n\n**Tip**: Look at the resulting **vectors** and, use `?seq()` or search online to understand the `seq()` **function** better.\n\n```{r eval=FALSE}\neven_seq <- seq(from = 0, to = 8, by = 2)\nodd_seq <- seq(from = 1, to = 9, by = 2)\nlong_seq <- seq(from = 10, to = 300, by = 10)\n```\n\nGrand! Now let us subset the **vectors** with square brackets `[]`.\n\n**Vectors** are one-dimensional, we therefore provide the square brackets with one number or one range of numbers. The number/s we provide in the square brackets are the index.\n\nTry out indexing/subsetting the **vectors**.\n\n```{r eval=FALSE}\neven_seq[2]\nodd_seq[1]\nlong_seq[10]\neven_seq[2:3]\nodd_seq[1:4]\nlong_seq[21:24]\nlong_seq[24:21]\neven_seq[c(2,3)]\nodd_seq[c(1,3,2,5)]\nlong_seq[c(1,21,21:24,24:21,1)]\n#As long as the contents within the [] equal numbers they will work\neven_seq[seq(from = 1, to = 3, by = 2)]\neven_seq[seq(from = 0, to = 5, by = 3)]\nlong_seq[seq(from = 1, to = 19, by = 2)]\neven_seq[1*2]\nodd_seq[2/1]\nlong_seq[(1:10)*2]\n```\n\nThe **vectors** even_seq and odd_seq have the indexes 1,2,3,4, and 5 as they each contain 5 **scalars**. What if we try to use a higher number to index than is available?\n\n```{r eval=FALSE}\neven_seq[6]\neven_seq[c(4,7)]\nodd_seq[3:9]\n```\n\nAs you can see the above all work with no complaints. Any indexes that are out of range will return a `NA` value. `NA` stands for 'Not Available'. We will not go into how `NA` works in R too much. The most important thing to know about `NA` is that you will most likely get `NA` if you use **operators** or **functions** with `NA`. Below are a few examples:\n\n```{r eval=FALSE}\n#Will give NA\n1 + NA\n2 - NA\neven_seq[2] * NA\nodd_seq[5] / NA\n#mean() function without NA\nmean(even_seq[2:5])\n#mean() function with NA\nmean(c(1,2,3,4,5,NA))\nmean(even_seq[2:7])\n```\n\nAbove we subsetted **vectors** by specifying which indexes we want. We can also specify which indexes we don't want:\n\n```{r eval=FALSE}\neven_seq[-2]\nodd_seq[-3:-5]\nlong_seq[c(-1,-2,-6)]\n```\n\nThe `rep()` **function** will replicate a **scalar/vector** a specified amount of times. We will use this **function** to overwrite our previously created **variables** with longer versions:\n\n```{r eval=FALSE}\n#Replicate vector even_seq 2 times\nrep(x = even_seq, 2)\n#Replicate vector even_seq 4 times and then assign even_seq as the newly created vector\neven_seq <- rep(x = even_seq, 4)\n#More examples\nodd_seq <- rep(x = odd_seq, 4)\nlong_seq <- rep(x = long_seq, 3)\n```\n\n**Logical** **operators** can be used as indexes to subset **vectors**. Having a logical expression (i.e. 1 \\> 2) as the index will cause all TRUE positions to be included and all FALSE positions to be excluded.\n\n**Tip**: If it is difficult to deduce what the below commands are doing you can run the part in the square brackets by itself. Remember if you highlight code in the **script editor** it will only run that part, excluding unhighlighted parts of script in the same line.\n\n```{r eval=FALSE}\neven_seq > 3\neven_seq[even_seq  > 2]\nodd_seq[odd_seq <= 1 ]\nlong_seq <- long_seq[long_seq < 50]\n```\n\nWe will quickly look at a new **operator**, `%%`. This is the modulus **operator**, it divides two numbers and gives the remainder of the division.\n\nWith the modulus **operator**, logical expressions, and subsetting we can extract even or odd numbers from a **vector**:\n\n```{r eval=FALSE}\n#First some basic modulus examples\n2%%2\n3%%2\n#Create a vector with numbers 0 to 9\nsingle_digit_vec <- 0:9\n#Extract even numbers then odd numbers from the vector\n#We carry this out by determining if numbers are divisible by 2 or not\neven_seq <- single_digit_vec[(single_digit_vec %% 2) == 0 ]\nodd_seq <- single_digit_vec[(single_digit_vec %% 2) != 0]\n#We can determine which numbers in a vector are divisible by any specific number\n#Divisible by 3\n#remember variable names cannot start with numbers\ndivis_3_vec <- single_digit_vec[(single_digit_vec %% 3) == 0]\n#Divisible by 7\ndivis_7_vec <- single_digit_vec[(single_digit_vec %% 7) == 0]\n#Try out other numbers!\n```\n\n### Data frames\n\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/envelope.png\")\n```\n\n**Data frames** can be subset similar to **vectors**. As with **vectors** you can use `[]`. Additionally, `$` can be used to subset **data frames**.\n\nSquare brackets must be provided indexes for rows and for columns. The structure for this is `df[row,column]`. It is very useful to remember that R always wants rows first then columns second.\n\nTo practice subsetting **data frames** with square brackets we will **read** in a new file called - **Census_2011_L\\_postcodes_counts.csv**\\]. This contains UK 2011 census information on total residents for postcodes that start with the letter L.\n\nDownload the following file into your \"Chapter_7\" directory:\n\n```{r echo=FALSE}\nlibrary(downloadthis)\ndownload_link(\n  link=\"https://m-gemmell.github.io/R_for_everyone/downloads/Census_2011_L_postcodes_counts.csv\",\n  button_label = \"Download Census_2011_L_postcodes_counts.csv\",\n  button_type = \"danger\",\n  has_icon = TRUE,\n  icon = \"fa fa-save\",\n  self_contained = TRUE\n)\n```\n\n<br> The source of the data is: <https://www.nomisweb.co.uk/census/2011/postcode_headcounts_and_household_estimates>\n\nRead the downloaded file into R:\n\n```{r eval=FALSE}\nL_2011_census_df <- read.csv(\"Census_2011_L_postcodes_counts.csv\",\n                             check.names = FALSE,\n                             row.names = 1)\n```\n\nNow for some subset commands:\n\n```{r eval=FALSE}\n#Scalar from the 1st row and 1st column\nL_2011_census_df[1,1]\n#Row names and column names can be used for indexing\n#Scalar from the row called L10 1LD and the column called Area\nL_2011_census_df[\"L10 1LD\",\"Area\"]\n#More examples\nL_2011_census_df[1:10,2]\nL_2011_census_df[1:10,\"District\"]\nL_2011_census_df[3,2:4]\nL_2011_census_df[\"L10 1LD\",2]\nL_2011_census_df[1:10,\"Total\"]\nL_2011_census_df[c(1,3,5,6),c(\"Total\",\"Occupied_Households\")]\n```\n\nDepending on how you subset a **data frame** you may get a **scalar**, **vector**, or **data frame**. Below describes which you will get based on the subsetting.\n\n-   **Scalar**:\n\n    -   Indexing to get a single value by choosing one row and one column.\n    -   E.g. `L_2011_census_df[1,1]`\n\n-   **Vector**:\n\n    -   Indexing so you get multiple values from one column. This occurs as each column is in essence a **vector**.\n    -   E.g. `L_2011_census_df[1:10,2]`\n\n-   **Data frame**:\n\n    -   Indexing so you get multiple values from a row or multiple rows. Subsetting a **data frame** like this provides you a **data frame**.\n    -   E.g. `L_2011_census_df[3,2:4]` or `L_2011_census_df[3:4,2:4]`\n\nA quick **function** to subset a **data frame** is `head()`. By default it will return the first 6 rows.\n\n```{r eval=FALSE}\n#Return first 6 rows\nhead(L_2011_census_df)\n#Return first 10 rows\nhead(L_2011_census_df, 10)\n```\n\nThe **data frame** is quite large. We will therefore use the `head()` **function** and the **assignment operator** to make the **data frame** smaller for further examples.\n\n```{r eval=FALSE}\nL_2011_census_df <- head(L_2011_census_df, 20)\n```\n\nTo return all the rows of the specified columns you can leave the part before the comma empty. Similarly you can leave the part after the comma empty to return all of the columns of the specified rows. Leave both sides empty and you will get the entire **data frame**.\n\n```{r eval=FALSE}\nL_2011_census_df[,]\nL_2011_census_df[,2]\nL_2011_census_df[3,]\nL_2011_census_df[,\"District\"]\nL_2011_census_df[2:4,]\n```\n\nThe sign `$` allows you to indicate which column you would like from the **data frame**. This is done like so:\n\n```{r eval=FALSE}\nL_2011_census_df$Area\nL_2011_census_df$District\nL_2011_census_df$Total\n```\n\nYou will notice that the above commands return **vectors**. We can therefore subset these **vectors** with `[]`:\n\n```{r eval=FALSE}\nL_2011_census_df$Area[2]\nL_2011_census_df$District[2]\nL_2011_census_df$Total[4:7]\n```\n\nBelow are a selection of useful **functions** that can be used on **vectors**.\n\n```{r eval=FALSE}\n#Sum the values of a numeric vector\nsum(L_2011_census_df$Total)\n#Mean of the values of a numeric vector\nmean(L_2011_census_df$Total)\n```\n\nThe above **functions** are useful but limiting if you are working with **data frames**. Thankfully there are also many **functions** used specifically for **data frames** (they can also be used for matrices).\n\n```{r eval=FALSE}\n#Sum numeric columns\ncolSums(L_2011_census_df[,3:6])\n#Sum numeric rows\nrowSums(L_2011_census_df[,4:5])\n#Mean of numeric columns\ncolMeans(L_2011_census_df[,3:6])\n#Mean of numeric rows\nrowMeans(L_2011_census_df[,4:5])\n#Summary information for each column\n#This works for string and numeric columns with different outputs\nsummary(L_2011_census_df)\n```\n\nTry out some of the above commands with the entire **data frame**. Do they give an error? Is so, why?\n\nBefore we learn how to **write** data to a file I will introduce one more **data frame** associated **function**. `t()` which stands for transpose:\n\n```{r eval=FALSE}\nL_2011_census_df[3:5]\nt(L_2011_census_df[,3:5])\nsummary(t(L_2011_census_df[,3:5]))\n```\n\nTry the above commands without subsetting the **data frame**. What is happening and why?\n\n## Writing to a file\n\n```{r, fig.align = 'center',out.width= '20%', echo=FALSE }\nknitr::include_graphics(path = \"figures/R_writing.png\")\n```\n\nBefore we **write** data to a file we will create a new **data frame** from \"L_2011_census_df\".\n\nFirst I like to create a new **variable** from our old **variable** if there are many steps. This means if we make a mistake we can go back and recreate the new **variable**.\n\n```{r eval=FALSE}\nL_2011_census_t_df <- L_2011_census_df\n```\n\nNext step we will create a new column called \"Average_per_occupied_households\".\n\n**NOTE**: I am including many ways to subset columns as reminders. Normally I wouldn't have so many different ways in one command.\n\n**NOTE**: We are using \"\\_\" instead of spaces as R doesn't particularly like spaces in column names. We will see how to use spaces later.\n\n```{r eval=FALSE}\nL_2011_census_t_df$Average_per_occupied_households <- \n  L_2011_census_t_df[,3] / L_2011_census_t_df[,\"Occupied_Households\"]\n```\n\nHave a look at the current **data frame**. You may notice an `Inf` value. This appears as when you divide a number by 0 in R you will get `Inf`. I am not sure how a Post code has 174 residents and 0 Occupied households but it doesn't matter for us.\n\nThe final step before writing is to transpose the **data frame** leaving out the Area and District columns:\n\n```{r eval=FALSE}\n#Transpose dataframe\nL_2011_census_t_df <- t(L_2011_census_t_df[,3:7])\n#Check structure\nstr(L_2011_census_t_df)\n#It is not a dataframe\n#Let us therefore convert it to a data frame\nL_2011_census_t_df <- as.data.frame(L_2011_census_t_df)\n#Structure check\nstr(L_2011_census_t_df)\n```\n\nAfter all that let us **write** the **data frame** to a file called \"Census_info_2011.csv\". When **reading** from a file I prefer `read.csv()`, however when writing to a file I prefer `write.table()`. With this **function** we will include the option `sep=\",\"` to have commas as the column separators. We will also include the option `col.names=NA` to create an empty space above the row names. If this was not included then the first column name would be above the row names.\n\n```{r eval=FALSE}\nwrite.table(L_2011_census_t_df, file = \"Census_info_2011.csv\", sep = \",\", col.names=NA)\n```\n\nHave a look at the file contents with RStudio.\n\nLet us do it one more time with the clothing store info. First let us **read** in the file again in case you do not have it. Then we will create a total sales column and finally transpose the **data frame**:\n\n```{r eval=FALSE}\n#Read in\nclothing_df <- read.csv(\"Clothing_stores.tsv\", row.names = 1, \n                        sep = \"\\t\", check.names = FALSE)\n#Create total column\n#We are referring to a column name with spaces\n#Therefore we must surround the name with `\n#The button for ` is left of the 1 key and below the esc key\nclothing_df$`Total sales` <- rowSums(clothing_df)\n#Transpose ensuring output is a data frame\nclothing_t_df <- as.data.frame(t(clothing_df))\n```\n\n**Write** the **data frame** to a tab delimited file (.tsv). This time we will make it so the row and column names are not surrounded by quotes:\n\n```{r eval=FALSE}\nwrite.table(clothing_t_df, \n            \"Clothing_stores_transposed.tsv\", \n            sep = \"\\t\",  \n            col.names=NA, \n            quote = FALSE)\n```\n\nWith the fundamentals of **reading**, subsetting **data frames**, and writing covered it is time to carry out some exercises.\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"07-Files_and_subsetting_data.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","editor":"source","theme":"cosmo","max-width":"3000px","toc-location":"left","toc-title":"In this chapter","margin":0,"page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
{
  "hash": "65709cb3ac2eaa00e60c1f6049c320c9",
  "result": {
    "markdown": "# R objects\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/RObjects.png){fig-align='center' width=20%}\n:::\n:::\n\n\nIn Chapter 2 we learnt how to create a __variable__. This consisted of assigning (`<-`) an __object__ a name. In this chapter we will learn about __R objects__. There are two major R terminologies to learn to fully understand __R objects__.\n\n- __Class__: An __R object__ will have a specific class. The __class__ determines what the __object__ is. It could be numbers, text, or other types of __classes__.\n- __Data structure__: This determines the structure of an __R object__.\n\nThe rest of today's plan is to learn about __classes__ and __data structures__.\n\n## Code sections\nToday, and for the rest of the course, you will use code sections in your R scripts to separate sections in this book.\n\nFirst set your working directory to the course directory, create a script, and save it as __\"2-Objects.R\"__.\n\nNext create a code section at the top of this script called __\"Classes\"__.\n\nIn other words have the below at the top of your script:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Classes ####\n```\n:::\n\n\n\n## Classes\nThere are six basic __classes__ in R (Also known as the __atomic classes__). \n\nThe four we will learn are:\n\n- __Integer__\n- __Double__\n- __String__\n- __Logical__\n\nThere are also the classes __complex__ and __raw__.\n\n### Numeric\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/numbers.png){fig-align='center' width=20%}\n:::\n:::\n\n\n\n__Numeric__ __classes__ come in two types, __integer__ and __double__. __Integers__ and __doubles__ are almost identical. However, __doubles__ contain decimal point information whilst __integers__ do not. \n\nMost of the time you will only need to know if your data is __numeric__ and you will not need to worry about __doubles__ or __integers__. The exception being if you are working with decimals and your decimals are not showing up. This probably means that your __object__ has the __integer class__.\n\nType and run the following, using the provided annotation to understand what the commands are doing.\n\n__Note:__ Remember you can copy and paste old script.\n\nUse the __function__ `class()` to show the __class__ of an R __object__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Numeric\n#Class of 2\nclass(2)\n#class of 3.14\nclass(3.14)\n#class of 6\nclass(6)\n```\n:::\n\n\n\nCreate a __variable__ with the __name__ \"pie\"\" containing the __numeric__ 3.14:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Creating a variable using the assignment operator\npie <- 3.14\n```\n:::\n\n\n\nUse the __functions__ `as.numeric()`, `as.integer()`, and `as.double()` to print the __variable__ as a __numeric__, as an __integer__, and as a __double__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Printing out previously made variable as numeric, integer, and double\nas.numeric(pie)\nas.integer(pie)\nas.double(pie)\n```\n:::\n\n\n\nYou can put a __function__ as the __variable__ within a __function__. \n\nBelow we will first check the __class__ of the __object__ within the \"pie\" __variable__. You will note that the __functions__ we used previously did not permanently change the __variable's object__. We can only change a __variable__ if we use the __assignment operator__.\n\nThen we will check the __class__ of the __object__ as it is altered by the various `as.` __functions__. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Checking the class of our variable\nclass(pie)\nclass(as.numeric(pie))\nclass(as.integer(pie))\nclass(as.double(pie))\n```\n:::\n\n\n\n__Note:__ Remember to ask for help if you need it!\n\nOn a side note, R comes with some inbuilt variables such as pi:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#The R pi is equal to 3.141593\npi\n#assign pi to 3.14\npi <- 3.14\n#print out pi to see you have changed the variable's object\npi\n#in this case if you want the original R pi object back, we can remove the one we made\nrm(pi)\n```\n:::\n\n\n\nHave you been annotating your scripts?\n\n### Logical\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/logical.png){fig-align='center' width=20%}\n:::\n:::\n\n\n__Logical__ values can be __TRUE__ or __FALSE__. \n\nThey are primarily used when comparing objects.\n\nRun the below commands to output __Logical__ values using the various __logical operators__.\n\nNote: when `!` is used in __operators__ it means \"not\". When used, `!` always goes at the front of the operator.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Logical\n# 2 less than 4 \n2 < 4\n# 2 greater than 4\n2 > 4\n# 2 less than or equal to 4\n2 <= 4\n# 2 greater than or equal to 4\n2 >= 4\n# 2 equal to 4\n2 == 4\n# 2 not not equal to 4\n2 != 4\n```\n:::\n\n\n\nIt is probably not immediately obvious how useful __logicals__ are, but you'll see their usefulness later in the course.\n\n### String\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/string_bubble.png){fig-align='center' width=20%}\n:::\n:::\n\n\n__Strings__ are text and can be modified in R in ways you would normally want to modify text. They are called __strings__ as they are strings of characters. __Strings__ are flanked by quote marks. Double quotes (`\"\"`) are preferred but single quotes can also be used (`''`).\n\nType and run the below examples to get some practice with __strings__.\n\nA __string object__ can consist of a string containing one __character__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#String\none_character_string <- \"A\"\none_character_string\n```\n:::\n\n\n\nA __string object__ can consist of a string containing multiple __characters__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_string <- \"alphabet\"\nword_string\n```\n:::\n\n\n\nA __string__ can contain all the different characters and any number of them. The only exception is that if you try to put a double quote in your string it will cause an issue.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_string <- \"Strings can be long and contain more than letters. \\\\.(\"\nlong_string\n```\n:::\n\n\n\nA __string__ doesn't need letters, it can consist of only numbers. Note the terms __string__ and __character__ can be used interchangeably.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber_string <- \"1066\"\nnumber_string\nclass(number_string)\n```\n:::\n\n\n\nYou can convert a __numeric__ to a __string/character__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber <- 1066\nnumeric_to_string <- as.character(number)\nnumeric_to_string\nclass(numeric_to_string)\n```\n:::\n\n\n\nAn appropriate __string__ can be converted to a __numeric__. This is useful as mathematical __operators__ will not work with __strings__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#will get an error as strings and maths don't mix\n\"6\" - 3\n#will work as maths and numerics work\nas.numeric(\"6\") - 4\n#Below will not work as only strings containing numbers can be converted to numeric\nas.numeric(\"not_a_number_12\")\n```\n:::\n\n\n\nYou can use certain __logical operators__ to compare __strings__ though:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"character\" == \"character\"\n\"1066\" != \"character\"\n\"numeric\" == \"string\"\n```\n:::\n\n\n\nThe __paste() function__ is very useful to combine two or more __strings__ into one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"The following is a string:\", long_string) \npaste(number_string, \"and the\", word_string)\n#By default paste will put a space (sep = \" \") between each string you provide\n#You can use the sep option to specify your own\npaste(\"However\", \" this is separated by a comma\", sep = \",\")\n#Or you can make it so there is no separator\npaste(\"no separator\",numeric_to_string, sep = \"\")\n#Alternatively you can use paste0()\n#Where there is no separator by default (sep =\"\")\npaste0(\"no separator\",numeric_to_string)\n```\n:::\n\n\n\n## Code section continued\nAfter all that you will have some nice code and annotations in your script editor for the __Classes__ code section.\n\nMaking a code section is not very useful until you have multiple code sections. To show this create a new code section at the bottom of your script called __\"Data structures\"__. This new code section will be used for the next section.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data structures ####\n```\n:::\n\n\n\nWith the new code section created we can now see why code sections are so useful. Go to the text that denotes the first code section (__\"Classes\"__). Look between the numbers on the left that signify the line number, and the text. You will see an arrow pointing downwards. You can click that arrow and it will collapse the code section. Click the arrow, now pointing right, and it will expand the code section. This is super useful so you can hide code sections in your script that you don't currently need to look at.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/R_code_section_collapse.png){fig-align='center' width=20%}\n:::\n:::\n\n\n\nWith the __\"Classes\"__ code section collapsed let us continue to the next section. There will be less annotations in this book as I expect you will make your own now.\n\n## Data structures\n\n__Data structures__ describe how data is structured in an __object__. We will go into 3 main types of __data structures__.\n\n- __Scalar__\n- __Vectors__ & __Lists__\n- __Matrices__ & __Data frames__\n\n### Scalar\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/Rscalar.png){fig-align='center' width=15%}\n:::\n:::\n\n\nA __scalar__ consists of one value in an object. This can be one __string__, one __numeric__, one __logical__ etc. We have only been working with __scalars__ thus far but this is about to change. \n\n### Vectors & Lists\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/Rvector.png){fig-align='center' width=20%}\n:::\n:::\n\n\n\nA __R object__ can hold multiple values. Many __data__ structures can do this with the simplest being a __vector__.\n\nA __vector__ can be created with the `c()` __function__. This function will combine the provided objects into a single __vector__ or __list__.\n\n__Vectors__ and __lists__ are both 1-dimensional __data structures__. __Vectors__ can only contain one __class__ (homogeneous) whilst __lists__ can contain multiple (heterogeneous). There is more to __lists__ but we will not go into them.\n\nRun the following commands to produce __variables__ which contain __vectors__.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber_vec <- c(1,2,4,8,16)\nnumber_vec\nnumber_series_vec <- 1:6\nnumber_series_vec\nanimals <- c(\"Whale\",\"Seal\",\"Hedgehog\",\"Mouse\",\"Owl\",\"Squirrel\",\"Vole\",\"Shrew\")\nanimals\n```\n:::\n\n\n\nElements of a __vector__ can be accessed through their indices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbirds <- animals[5]\nbirds\naquatic <- animals[1:2]\naquatic\nrodents <- animals[c(4,6,7)]\nrodents\nmammals <- animals[-5]\nmammals\n```\n:::\n\n\n\nYou can use __operators__ and __functions__ on a __vector__. When you do each __scalar__ within the __vector__ will be acted upon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber_vec - 1\nnumber_vec * 2\nlog(number_vec)\nlength(rodents)\n```\n:::\n\n\n\nSome __functions__ are specifically used for __vectors__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(number_vec)\nsummary(number_vec)\n```\n:::\n\n\n\nWe can also test the values within __vectors__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naquatic == \"Whale\"\nnumber_vec > 4\nnumber_vec[number_vec > 4]\n```\n:::\n\n\n\nThe `paste()` __function__ can be used to paste __string scalars__ to other __string scalars__ or to __string vectors__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"Animals\", animals)\nbird_or_mammal <- c(\"mammal\",\"mammal\",\"mammal\",\"mammal\",\"bird\",\"mammal\",\"mammal\",\"mammal\")\npaste(animals, bird_or_mammal, sep = \":\")\npaste(animals, \" is a \", bird_or_mammal, sep = \"\")\n```\n:::\n\n\n\n### Data frames & Matrices\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/Rmatrix.png){fig-align='center' width=20%}\n:::\n:::\n\n\n\n__Data frames__ & __matrices__ are 2-dimensional data structures as they have rows and columns.\n\nA __matrix__ only contains 1 __class__ (homogeneous). A __data frame__ can contain multiple __classes__ (heterogeneous), but each column can only contain one __class__. \n\nMost of the time __data frames__ and __matrices__ can be treated the same. Because of this I generally use __data frames__ and so we will focus on them.\n\nR comes with a set of pre-loaded data. If you are interested you can use the __function__ `data()` to see the full list.\n\nWe will have a quick look at the dataset \"mtcars\". This is a __data frame__ containing information on various cars. To look at the __data frame__ in the __console window__ run the below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars\n```\n:::\n\n\n\nTo get a better look save the __data frame__ as a __variable__.\nThe above shows the info in the __console window__. However we can have a better look at it in RStudio if we save it as a variable in our __environment__ and then click the variable on the __Environment pane__ of the __\"environment and history\"__ __window__.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_info <- mtcars\n```\n:::\n\n\n\nNow the __variable__ will be listed in your __Environment pane__ in the __\"environment and history\" window__ . Click on the name \"cars_info\" in the __Environment pane__. A tab in your __script editor__ will open so you can have a good look at the contents of the __data frame__.\n\nWhen you are ready, close the \"cars_info\" tab and remove the __variable__ with the below command.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(cars_info)\n```\n:::\n\n\n\nNow it is time to create our own __data frame__.\n\nFirst we will create three __variables__ containing __vectors__. These will be our three columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCrab <- c(10,1,1)\nOystercatcher <- c(5,6,4)\nStarfish <- c(3,3,7)\n```\n:::\n\n\n\nNow let us create the __data frame__.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Using the function data.frame to create a data frame\nbeach_df <- data.frame(Crab,Oystercatcher,Starfish)\n```\n:::\n\n\n\nLook at the __variable__ \"beach_df\" (it is useful to use \"df\" in __variable names__ to signify it is a __data frame__) and you will see that each __vector__ has become a column. The __variable names__ have become the column names (this is why we used capital letters in the __variable names__).\n\nYou can think of __data frames__ in three different ways:\n\n- A list of columns\n- A list of rows\n- A table\n\nLook at the column and row names with two new __functions__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(beach_df)\nrow.names(beach_df)\n```\n:::\n\n\n\nWe can use the __function__ `row.names()` and the __assignment operator__ to change the row names to something more useful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrow.names(beach_df) <- c(\"Formby\",\"West Kirby\",\"Crosby\")\n```\n:::\n\n\n\nNow look at your \"beach_df\" __data frame__ to see the difference.\n\nThat is quite a lot to go through so let us reinforce it all with exercise!\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}